<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Dashboard - FlowLink</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=PT+Sans:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="global.css">
    <style>
        :root {
            --admin-accent: #29ABE2;
            --danger-color: #EF4444;
            --success-color: #10B981;
            --warning-color: #F59E0B;
        }

        * {
            box-sizing: border-box;
        }

        .admin-dashboard-page {
            background: linear-gradient(135deg, #E5F6FD 0%, rgba(41, 171, 226, 0.1) 100%);
            min-height: 100vh;
            display: flex;
            font-family: 'PT Sans', sans-serif;
        }

        /* Sidebar Styles */
        .admin-sidebar {
            width: 280px;
            background: linear-gradient(180deg, #1F2933 0%, #2D3748 100%);
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s ease;
        }

        .admin-sidebar.collapsed {
            transform: translateX(-280px);
        }

        .sidebar-header {
            padding: 2rem 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar-logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .sidebar-logo i {
            font-size: 1.8rem;
            color: #29ABE2;
        }

        .sidebar-logo span {
            font-family: 'Poppins', sans-serif;
            font-size: 1.4rem;
            font-weight: 700;
            color: white;
        }

        .admin-badge {
            display: inline-block;
            background: linear-gradient(135deg, var(--admin-accent), #29E2D0);
            color: white;
            font-size: 0.6rem;
            font-weight: 600;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            margin-left: 0.5rem;
            text-transform: uppercase;
        }

        .sidebar-nav {
            flex: 1;
            padding: 2rem 0;
            overflow-y: auto;
        }

        .nav-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .nav-item {
            margin-bottom: 0.5rem;
            cursor: pointer;
        }

        .nav-link {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem 1.5rem;
            color: rgba(255, 255, 255, 0.7);
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
            border-left: 3px solid transparent;
        }

        .nav-link:hover {
            background: rgba(255, 255, 255, 0.05);
            color: white;
            border-left-color: var(--admin-accent);
        }

        .nav-item.active .nav-link {
            background: rgba(41, 171, 226, 0.2);
            color: white;
            border-left-color: var(--admin-accent);
        }

        .nav-icon {
            font-size: 1.2rem;
            width: 24px;
            text-align: center;
        }

        .nav-badge {
            background: var(--danger-color);
            color: white;
            font-size: 0.7rem;
            padding: 0.15rem 0.5rem;
            border-radius: 10px;
            margin-left: auto;
        }

        .sidebar-footer {
            padding: 1.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .admin-profile {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .admin-avatar {
            width: 45px;
            height: 45px;
            border-radius: 12px;
            background: linear-gradient(135deg, var(--admin-accent), #29E2D0);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .admin-info {
            overflow: hidden;
        }

        .admin-info .admin-name {
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            color: white;
            font-size: 0.95rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .admin-info .admin-role {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8rem;
        }

        /* Main Content Area */
        .admin-main {
            flex: 1;
            margin-left: 280px;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            transition: margin-left 0.3s ease;
        }

        .admin-main.expanded {
            margin-left: 0;
        }

        /* Top Bar */
        .admin-topbar {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(41, 171, 226, 0.1);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .topbar-left {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .mobile-menu-btn {
            display: none;
            background: none;
            border: none;
            color: #4B5563;
            font-size: 1.3rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 8px;
        }

        .page-title {
            font-family: 'Poppins', sans-serif;
            font-size: 1.5rem;
            font-weight: 600;
            color: #1F2933;
            margin: 0;
        }

        .topbar-badge {
            background: linear-gradient(135deg, var(--admin-accent), #29E2D0);
            color: white;
            font-size: 0.75rem;
            font-weight: 600;
            padding: 0.35rem 0.75rem;
            border-radius: 20px;
        }

        .topbar-right {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .back-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            background: rgba(0, 0, 0, 0.05);
            color: #4B5563;
            border: none;
            border-radius: 10px;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        .sign-out-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, var(--admin-accent), #29E2D0);
            color: white;
            border: none;
            border-radius: 10px;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .sign-out-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(41, 171, 226, 0.4);
        }

        /* Content Area */
        .admin-content {
            flex: 1;
            padding: 2rem;
        }

        .page-section {
            display: none;
        }

        .page-section.active {
            display: block;
        }

        /* Metrics Grid */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .metric-card {
            background: white;
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(41, 171, 226, 0.1);
            transition: all 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }

        .metric-icon {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            color: white;
            margin-bottom: 1rem;
        }

        .metric-icon.members { background: linear-gradient(135deg, #29ABE2, #29E2D0); }
        .metric-icon.problems { background: linear-gradient(135deg, #EF4444, #F97316); }
        .metric-icon.solved { background: linear-gradient(135deg, #10B981, #059669); }
        .metric-icon.pending { background: linear-gradient(135deg, #F59E0B, #D97706); }
        .metric-icon.join { background: linear-gradient(135deg, #8B5CF6, #A78BFA); }
        .metric-icon.branch { background: linear-gradient(135deg, #EC4899, #F472B6); }
        .metric-icon.escalation { background: linear-gradient(135deg, #F59E0B, #EF4444); }
        .metric-icon.archived { background: linear-gradient(135deg, #6B7280, #9CA3AF); }

        .metric-value {
            font-family: 'Poppins', sans-serif;
            font-size: 2rem;
            font-weight: 700;
            color: #1F2933;
            margin-bottom: 0.25rem;
        }

        .metric-label {
            color: #6B7280;
            font-size: 0.9rem;
        }
</style>
</head>
<body class="admin-dashboard-page">
    <aside class="admin-sidebar" id="adminSidebar">
        <div class="sidebar-header">
            <div class="sidebar-logo"><i class="fas fa-project-diagram"></i><span>FlowLink<span class="admin-badge">Admin</span></span></div>
        </div>
        <nav class="sidebar-nav">
            <ul class="nav-list">
                <li class="nav-item active" data-page="dashboard"><a class="nav-link"><i class="fas fa-chart-line nav-icon"></i><span>Dashboard</span></a></li>
                <li class="nav-item" data-page="join-requests"><a class="nav-link"><i class="fas fa-user-plus nav-icon"></i><span>Join Requests</span><span class="nav-badge" id="joinBadge" style="display:none;">0</span></a></li>
                <li class="nav-item" data-page="branch-requests"><a class="nav-link"><i class="fas fa-code-branch nav-icon"></i><span>Branch Requests</span><span class="nav-badge" id="branchBadge" style="display:none;">0</span></a></li>
                <li class="nav-item" data-page="subnodes"><a class="nav-link"><i class="fas fa-sitemap nav-icon"></i><span>Sub-Nodes</span></a></li>
                <li class="nav-item" data-page="members"><a class="nav-link"><i class="fas fa-users nav-icon"></i><span>Members</span></a></li>
                <li class="nav-item" data-page="problems"><a class="nav-link"><i class="fas fa-exclamation-triangle nav-icon"></i><span>Problems</span></a></li>
                <li class="nav-item" data-page="announcements"><a class="nav-link"><i class="fas fa-bullhorn nav-icon"></i><span>Announcements</span></a></li>
            </ul>
        </nav>
        <div class="sidebar-footer">
            <div class="admin-profile">
                <div class="admin-avatar"><i class="fas fa-user-shield"></i></div>
                <div class="admin-info"><div class="admin-name" id="adminDisplayName">Admin</div><div class="admin-role">Organization Admin</div></div>
            </div>
        </div>
    </aside>
    <div class="mobile-overlay" id="mobileOverlay"></div>
    <main class="admin-main" id="adminMain">
        <header class="admin-topbar">
            <div class="topbar-left">
                <button class="mobile-menu-btn" id="mobileMenuBtn"><i class="fas fa-bars"></i></button>
                <h1 class="page-title" id="pageTitle">Admin Dashboard</h1>
                <span class="topbar-badge">Organization Admin</span>
            </div>
            <div class="topbar-right">
                <button class="back-btn" id="backToDashboardBtn"><i class="fas fa-arrow-left"></i><span>Back to Dashboard</span></button>
                <button class="sign-out-btn" id="signOutBtn"><i class="fas fa-sign-out-alt"></i><span>Sign Out</span></button>
            </div>
        </header>
        <div class="admin-content" id="adminContent">
            <div class="loading-spinner" id="loadingSpinner"><i class="fas fa-spinner"></i></div>
            <div class="not-admin-message" id="notAdminMessage" style="display: none;">
                <i class="fas fa-exclamation-circle"></i>
                <h2>Access Denied</h2>
                <p>You are not an admin of any organization. Please contact the Super Admin if you believe this is an error.</p>
                <button class="btn-primary" onclick="window.location.href='dashboard.html'"><i class="fas fa-arrow-left"></i> Back to Dashboard</button>
            </div>
            <div id="adminContentWrapper" style="display: none;">
                <div class="section-header">
                    <h2 class="section-title">Select Organization</h2>
                    <div class="org-selector"><label for="orgSelect">Organization:</label><select id="orgSelect"></select></div>
                </div>
                <!-- Dashboard Page - Problem Governance & Approval Center -->
                <section class="page-section active" id="dashboardPage">
                    <!-- Metrics Grid -->
                    <div class="metrics-grid">
                        <div class="metric-card"><div class="metric-icon members"><i class="fas fa-users"></i></div><div class="metric-value" id="totalMembers">0</div><div class="metric-label">Total Members</div></div>
                        <div class="metric-card"><div class="metric-icon pending"><i class="fas fa-clipboard-check"></i></div><div class="metric-value" id="pendingApprovalsCount">0</div><div class="metric-label">Pending Approvals</div></div>
                        <div class="metric-card"><div class="metric-icon problems"><i class="fas fa-exclamation-triangle"></i></div><div class="metric-value" id="totalProblems">0</div><div class="metric-label">Open Problems</div></div>
                        <div class="metric-card"><div class="metric-icon escalation"><i class="fas fa-level-up-alt"></i></div><div class="metric-value" id="escalatedCount">0</div><div class="metric-label">Escalated</div></div>
                        <div class="metric-card"><div class="metric-icon solved"><i class="fas fa-check-circle"></i></div><div class="metric-value" id="solvedProblems">0</div><div class="metric-label">Solved Problems</div></div>
                        <div class="metric-card"><div class="metric-icon archived"><i class="fas fa-archive"></i></div><div class="metric-value" id="archivedCount">0</div><div class="metric-label">Archived</div></div>
                    </div>
                    <!-- Hidden elements for backward compatibility -->
                    <span id="joinRequestCount" style="display:none;">0</span>
                    <span id="branchRequestCount" style="display:none;">0</span>

                    <!-- Governance Tabs -->
                    <div class="governance-tabs">
                        <button class="gov-tab active" data-tab="pending-approvals"><i class="fas fa-clipboard-list"></i> Pending Approvals <span class="tab-badge" id="pendingTabBadge">0</span></button>
                        <button class="gov-tab" data-tab="escalation-archive"><i class="fas fa-level-up-alt"></i> Escalation & Archive <span class="tab-badge" id="escalationTabBadge">0</span></button>
                    </div>

                    <!-- Pending Approvals Panel -->
                    <div class="governance-panel active" id="pending-approvals-panel">
                        <div class="panel-header">
                            <h3 class="panel-title"><i class="fas fa-clipboard-check"></i> Pending Approvals</h3>
                            <div class="panel-filters">
                                <button class="filter-chip active" data-filter="all">All</button>
                                <button class="filter-chip" data-filter="problem"><i class="fas fa-exclamation-circle"></i> Problems</button>
                                <button class="filter-chip" data-filter="escalation"><i class="fas fa-level-up-alt"></i> Escalations</button>
                            </div>
                        </div>
                        <div class="approval-list" id="pendingApprovalsList">
                            <div class="loading-spinner"><i class="fas fa-spinner"></i></div>
                        </div>
                    </div>

                    <!-- Escalation & Archive Panel -->
                    <div class="governance-panel" id="escalation-archive-panel">
                        <div class="panel-header">
                            <h3 class="panel-title"><i class="fas fa-level-up-alt"></i> Escalation & Archive Management</h3>
                        </div>
                        <div class="escalation-tabs">
                            <button class="esc-tab active" data-esctab="escalations"><i class="fas fa-arrow-up"></i> Escalations</button>
                            <button class="esc-tab" data-esctab="archived"><i class="fas fa-archive"></i> Archived</button>
                        </div>
                        <div class="escalation-content active" id="escalations-content">
                            <div class="escalation-list" id="escalationList">
                                <div class="loading-spinner"><i class="fas fa-spinner"></i></div>
                            </div>
                        </div>
                        <div class="escalation-content" id="archived-content">
                            <div class="archive-list" id="archiveList">
                                <div class="loading-spinner"><i class="fas fa-spinner"></i></div>
                            </div>
                        </div>
                    </div>

                    <!-- Recent Activity (kept for reference) -->
                    <div class="section-header" style="margin-top: 2rem;"><h2 class="section-title">Recent Activity</h2></div>
                    <div class="data-table" id="recentActivityTable"><div class="loading-spinner"><i class="fas fa-spinner"></i></div></div>
                </section>
                <!-- Join Requests Page -->
                <section class="page-section" id="joinRequestsPage">
                    <div class="section-header"><h2 class="section-title">Pending Join Requests</h2></div>
                    <div class="data-table" id="joinRequestsTable"><div class="loading-spinner"><i class="fas fa-spinner"></i></div></div>
                </section>
                <!-- Branch Requests Page -->
                <section class="page-section" id="branchRequestsPage">
                    <div class="section-header"><h2 class="section-title">Pending Branch Requests</h2></div>
                    <div class="data-table" id="branchRequestsTable"><div class="loading-spinner"><i class="fas fa-spinner"></i></div></div>
                </section>
                <!-- Sub-Nodes Page -->
                <section class="page-section" id="subnodesPage">
                    <div class="section-header">
                        <h2 class="section-title">Sub-Nodes Management</h2>
                        <button class="btn-primary" id="addSubnodeBtn"><i class="fas fa-plus"></i> Add Sub-Node</button>
                    </div>
                    <div class="subnode-tree" id="subnodeTree"><div class="loading-spinner"><i class="fas fa-spinner"></i></div></div>
                </section>
                <!-- Members Page -->
                <section class="page-section" id="membersPage">
                    <div class="section-header"><h2 class="section-title">Organization Members</h2></div>
                    <div class="data-table" id="membersTable"><div class="loading-spinner"><i class="fas fa-spinner"></i></div></div>
                </section>
                <!-- Problems Page -->
                <section class="page-section" id="problemsPage">
                    <div class="section-header"><h2 class="section-title">Problems</h2></div>
                    <div class="data-table" id="problemsTable"><div class="loading-spinner"><i class="fas fa-spinner"></i></div></div>
                </section>
                <!-- Announcements Page -->
                <section class="page-section" id="announcementsPage">
                    <div class="section-header"><h2 class="section-title">Announcements</h2></div>
                    <div class="data-table" id="announcementsTable"><div class="loading-spinner"><i class="fas fa-spinner"></i></div></div>
                </section>
            </div>
        </div>
    </main>

<style>
        .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; flex-wrap: wrap; gap: 1rem; }
        .section-title { font-family: 'Poppins', sans-serif; font-size: 1.25rem; font-weight: 600; color: #1F2933; }
        .org-selector { display: flex; align-items: center; gap: 0.75rem; }
        .org-selector label { font-weight: 600; color: #4B5563; }
        .org-selector select { padding: 0.5rem 1rem; border: 2px solid rgba(41, 171, 226, 0.2); border-radius: 8px; font-size: 0.9rem; background: white; cursor: pointer; }
        .org-selector select:focus { outline: none; border-color: var(--admin-accent); }
        .data-table { width: 100%; background: white; border-radius: 16px; overflow: hidden; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05); margin-bottom: 2rem; }
        .data-table table { width: 100%; border-collapse: collapse; }
        .data-table th, .data-table td { padding: 1rem 1.5rem; text-align: left; }
        .data-table th { background: rgba(41, 171, 226, 0.05); font-family: 'Poppins', sans-serif; font-weight: 600; color: #1F2933; font-size: 0.9rem; }
        .data-table td { border-bottom: 1px solid rgba(0, 0, 0, 0.05); color: #4B5563; }
        .data-table tr:last-child td { border-bottom: none; }
        .data-table tr:hover td { background: rgba(41, 171, 226, 0.02); }
        .status-badge { display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.35rem 0.75rem; border-radius: 20px; font-size: 0.8rem; font-weight: 600; }
        .status-badge.active { background: rgba(16, 185, 129, 0.1); color: #059669; }
        .status-badge.pending { background: rgba(245, 158, 11, 0.1); color: #D97706; }
        .status-badge.high { background: rgba(239, 68, 68, 0.1); color: #DC2626; }
        .status-badge.medium { background: rgba(245, 158, 11, 0.1); color: #D97706; }
        .status-badge.low { background: rgba(59, 130, 246, 0.1); color: #2563EB; }
        .status-badge.join { background: rgba(139, 92, 246, 0.1); color: #7C3AED; }
        .status-badge.branch { background: rgba(236, 72, 153, 0.1); color: #DB2777; }
        .action-btn { padding: 0.5rem 1rem; border: none; border-radius: 8px; font-size: 0.85rem; font-weight: 600; cursor: pointer; transition: all 0.3s ease; margin-right: 0.5rem; }
        .action-btn.approve { background: rgba(16, 185, 129, 0.1); color: #059669; }
        .action-btn.approve:hover { background: #10B981; color: white; }
        .action-btn.reject { background: rgba(239, 68, 68, 0.1); color: #DC2626; }
        .action-btn.reject:hover { background: #EF4444; color: white; }
        .action-btn.view { background: rgba(41, 171, 226, 0.1); color: var(--admin-accent); }
        .action-btn.view:hover { background: var(--admin-accent); color: white; }
        .action-btn.assign { background: rgba(139, 92, 246, 0.1); color: #7C3AED; }
        .action-btn.assign:hover { background: #7C3AED; color: white; }
        .empty-state { text-align: center; padding: 3rem; color: #6B7280; }
        .empty-state i { font-size: 3rem; margin-bottom: 1rem; opacity: 0.5; }
        .empty-state h3 { font-family: 'Poppins', sans-serif; margin-bottom: 0.5rem; color: #1F2933; }
        .loading-spinner { display: flex; justify-content: center; align-items: center; padding: 3rem; }
        .loading-spinner i { font-size: 2rem; color: var(--admin-accent); animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .toast { position: fixed; bottom: 2rem; right: 2rem; background: white; padding: 1rem 1.5rem; border-radius: 12px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2); display: none; align-items: center; gap: 0.75rem; z-index: 3000; }
        .toast.show { display: flex; animation: toastIn 0.3s ease; }
        .toast.success { border-left: 4px solid #10B981; }
        .toast.error { border-left: 4px solid #EF4444; }
        @keyframes toastIn { from { opacity: 0; transform: translateY(1rem); } to { opacity: 1; transform: translateY(0); } }
        .modal-overlay { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 2000; padding: 1rem; }
        .modal-overlay.show { display: flex; }
        .modal { background: white; border-radius: 16px; width: 100%; max-width: 500px; max-height: 90vh; overflow-y: auto; animation: modalIn 0.2s ease; }
        @keyframes modalIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 1.5rem; border-bottom: 1px solid rgba(0, 0, 0, 0.1); }
        .modal-title { font-family: 'Poppins', sans-serif; font-size: 1.25rem; font-weight: 600; }
        .modal-close { background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #6B7280; }
        .modal-body { padding: 1.5rem; }
        .modal-footer { display: flex; justify-content: flex-end; gap: 0.75rem; padding: 1rem 1.5rem; border-top: 1px solid rgba(0, 0, 0, 0.1); }
        .detail-row { display: flex; justify-content: space-between; padding: 0.75rem 0; border-bottom: 1px solid rgba(0, 0, 0, 0.05); flex-wrap: wrap; gap: 0.5rem; }
        .detail-row:last-child { border-bottom: none; }
        .detail-label { color: #6B7280; font-weight: 500; }
        .detail-value { color: #1F2933; font-weight: 600; }
        .form-group { margin-bottom: 1rem; }
        .form-label { display: block; font-weight: 600; margin-bottom: 0.5rem; color: #1F2933; }
        .form-input { width: 100%; padding: 0.75rem 1rem; border: 2px solid rgba(41, 171, 226, 0.2); border-radius: 10px; font-size: 1rem; transition: all 0.3s ease; }
        .form-input:focus { outline: none; border-color: var(--admin-accent); box-shadow: 0 0 0 3px rgba(41, 171, 226, 0.1); }
        .btn-primary { background: linear-gradient(135deg, var(--admin-accent), #29E2D0); color: white; padding: 0.75rem 1.5rem; border: none; border-radius: 10px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(41, 171, 226, 0.4); }
        .btn-secondary { background: rgba(0, 0, 0, 0.05); color: #4B5563; padding: 0.75rem 1.5rem; border: none; border-radius: 10px; font-weight: 600; cursor: pointer; }
        .mobile-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 999; opacity: 0; visibility: hidden; transition: all 0.3s ease; }
        .mobile-overlay.show { opacity: 1; visibility: visible; }
        .not-admin-message { text-align: center; padding: 4rem 2rem; background: white; border-radius: 16px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05); }
        .not-admin-message i { font-size: 4rem; color: #EF4444; margin-bottom: 1.5rem; }
        .not-admin-message h2 { font-family: 'Poppins', sans-serif; color: #1F2933; margin-bottom: 1rem; }
        .not-admin-message p { color: #6B7280; margin-bottom: 2rem; }
        .subnode-tree { background: white; border-radius: 16px; padding: 1.5rem; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05); }
        .subnode-item { padding: 1rem; border: 1px solid rgba(0,0,0,0.1); border-radius: 8px; margin-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem; }
        .subnode-item:hover { background: rgba(41, 171, 226, 0.02); }
        .subnode-info { flex: 1; min-width: 200px; }
        .subnode-name { font-weight: 600; color: #1F2933; }
        .subnode-meta { font-size: 0.85rem; color: #6B7280; }
        .subnode-actions { display: flex; gap: 0.5rem; flex-wrap: wrap; }
        @media (max-width: 768px) {
            .admin-sidebar { transform: translateX(-100%); }
            .admin-sidebar.show { transform: translateX(0); }
            .admin-main { margin-left: 0; }
            .mobile-menu-btn { display: block; }
            .metrics-grid { grid-template-columns: repeat(2, 1fr); }
            .admin-topbar { padding: 1rem; }
            .topbar-right { gap: 0.5rem; }
            .back-btn span, .sign-out-btn span { display: none; }
            .data-table { border-radius: 12px; }
            .data-table th, .data-table td { padding: 0.75rem 1rem; }
        }
        @media (max-width: 480px) {
            .metrics-grid { grid-template-columns: 1fr; }
            .admin-content { padding: 1rem; }
            .section-header { flex-direction: column; align-items: flex-start; }
            .org-selector { width: 100%; }
            .org-selector select { width: 100%; }
        }
        
        /* Tree View Styles for Branch Requests */
        .branch-tree-container { background: white; border-radius: 16px; padding: 1.5rem; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05); margin-bottom: 1.5rem; }
        .branch-tree-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 1px solid rgba(0,0,0,0.1); }
        .branch-tree-title { font-family: 'Poppins', sans-serif; font-weight: 600; color: #1F2933; }
        .branch-tree-requester { font-size: 0.85rem; color: #6B7280; }
        .tree-view { display: flex; flex-direction: column; align-items: center; padding: 1rem 0; overflow-x: auto; }
        .tree-node { display: flex; flex-direction: column; align-items: center; }
        .tree-node-card { min-width: 180px; max-width: 220px; background: white; border: 2px solid #E5E7EB; border-radius: 12px; padding: 0.75rem 1rem; text-align: center; transition: all 0.3s ease; }
        .tree-node-card.root { background: linear-gradient(135deg, var(--admin-accent), #29E2D0); color: white; border: none; }
        .tree-node-card.root .tree-node-type { color: rgba(255,255,255,0.8); }
        .tree-node-card.existing { background: #F9FAFB; border-color: #D1D5DB; }
        .tree-node-card.pending-request { background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(251, 191, 36, 0.1)); border: 2px dashed #F59E0B; animation: pulse-border 2s infinite; }
        @keyframes pulse-border { 0%, 100% { border-color: #F59E0B; } 50% { border-color: #FBBF24; } }
        .tree-node-name { font-family: 'Poppins', sans-serif; font-weight: 600; font-size: 0.9rem; margin-bottom: 0.25rem; }
        .tree-node-type { font-size: 0.75rem; color: #6B7280; text-transform: capitalize; }
        .tree-node-badge { display: inline-block; background: #F59E0B; color: white; font-size: 0.65rem; font-weight: 600; padding: 0.15rem 0.5rem; border-radius: 10px; margin-top: 0.5rem; }
        .tree-connector { width: 2px; height: 20px; background: #D1D5DB; }
        .tree-children { display: flex; justify-content: center; gap: 1rem; position: relative; padding-top: 20px; }
        .tree-children::before { content: ''; position: absolute; top: 0; left: 50%; transform: translateX(-50%); width: calc(100% - 100px); height: 2px; background: #D1D5DB; }
        .tree-child { display: flex; flex-direction: column; align-items: center; position: relative; }
        .tree-child::before { content: ''; position: absolute; top: -20px; left: 50%; width: 2px; height: 20px; background: #D1D5DB; }
        .tree-actions { display: flex; gap: 0.5rem; margin-top: 1rem; justify-content: center; flex-wrap: wrap; }
        .action-btn.merge { background: rgba(139, 92, 246, 0.1); color: #7C3AED; }
        .action-btn.merge:hover { background: #7C3AED; color: white; }
        .action-btn.restructure { background: rgba(236, 72, 153, 0.1); color: #DB2777; }
        .action-btn.restructure:hover { background: #DB2777; color: white; }
        .restructure-preview { background: #F9FAFB; border: 1px solid #E5E7EB; border-radius: 8px; padding: 1rem; margin: 1rem 0; }
        .restructure-preview .preview-title { font-weight: 600; margin-bottom: 0.5rem; color: #1F2933; }
        .restructure-preview .preview-path { display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap; font-size: 0.9rem; }
        .restructure-preview .preview-node { background: white; border: 1px solid #D1D5DB; padding: 0.25rem 0.75rem; border-radius: 6px; }
        .restructure-preview .preview-node.new { background: rgba(16, 185, 129, 0.1); border-color: #10B981; color: #059669; }
        .restructure-preview .preview-node.moved { background: rgba(245, 158, 11, 0.1); border-color: #F59E0B; color: #D97706; }
        .restructure-preview .preview-arrow { color: #9CA3AF; }

        /* ========== GOVERNANCE & APPROVAL CENTER STYLES ========== */
        
        /* Governance Tabs */
        .governance-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            background: white;
            padding: 0.5rem;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }
        
        .gov-tab {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            background: transparent;
            border: none;
            border-radius: 8px;
            font-family: 'Poppins', sans-serif;
            font-weight: 500;
            font-size: 0.9rem;
            color: #6B7280;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .gov-tab:hover {
            background: rgba(41, 171, 226, 0.1);
            color: var(--admin-accent);
        }
        
        .gov-tab.active {
            background: linear-gradient(135deg, var(--admin-accent), #29E2D0);
            color: white;
            box-shadow: 0 4px 15px rgba(41, 171, 226, 0.3);
        }
        
        .tab-badge {
            background: rgba(255, 255, 255, 0.3);
            padding: 0.15rem 0.5rem;
            border-radius: 10px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .gov-tab.active .tab-badge {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .gov-tab:not(.active) .tab-badge {
            background: var(--danger-color);
            color: white;
        }
        
        /* Governance Panels */
        .governance-panel {
            display: none;
            background: white;
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            animation: panelFadeIn 0.3s ease;
        }
        
        .governance-panel.active {
            display: block;
        }
        
        @keyframes panelFadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .panel-title {
            font-family: 'Poppins', sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
            color: #1F2933;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .panel-title i {
            color: var(--admin-accent);
        }
        
        .panel-filters {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .filter-chip {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.5rem 1rem;
            background: rgba(0, 0, 0, 0.05);
            border: none;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
            color: #6B7280;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .filter-chip:hover {
            background: rgba(41, 171, 226, 0.1);
            color: var(--admin-accent);
        }
        
        .filter-chip.active {
            background: var(--admin-accent);
            color: white;
        }
        
        /* Approval Items */
        .approval-list, .announcement-moderation-list, .escalation-list, .archive-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .approval-item {
            background: #FAFAFA;
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .approval-item:hover {
            border-color: var(--admin-accent);
            box-shadow: 0 4px 15px rgba(41, 171, 226, 0.1);
        }
        
        .approval-item.expanded {
            border-color: var(--admin-accent);
        }
        
        .approval-header {
            display: flex;
            align-items: center;
            padding: 1rem 1.25rem;
            cursor: pointer;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .approval-type-badge {
            padding: 0.35rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .approval-type-badge.problem {
            background: rgba(239, 68, 68, 0.1);
            color: #DC2626;
        }
        
        .approval-type-badge.announcement {
            background: rgba(41, 171, 226, 0.1);
            color: var(--admin-accent);
        }
        
        .approval-type-badge.escalation {
            background: rgba(245, 158, 11, 0.1);
            color: #D97706;
        }
        
        .approval-info {
            flex: 1;
            min-width: 200px;
        }
        
        .approval-title {
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            color: #1F2933;
            margin-bottom: 0.25rem;
        }
        
        .approval-meta {
            display: flex;
            gap: 1rem;
            font-size: 0.85rem;
            color: #6B7280;
            flex-wrap: wrap;
        }
        
        .approval-meta span {
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }
        
        .priority-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .priority-indicator.high { background: #EF4444; }
        .priority-indicator.medium { background: #F59E0B; }
        .priority-indicator.low { background: #3B82F6; }
        
        .approval-age {
            padding: 0.25rem 0.5rem;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 6px;
            font-size: 0.8rem;
            color: #6B7280;
        }
        
        .approval-age.urgent {
            background: rgba(239, 68, 68, 0.1);
            color: #DC2626;
            animation: pulse-urgent 2s infinite;
        }
        
        @keyframes pulse-urgent {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .approval-expand-btn {
            background: none;
            border: none;
            color: #6B7280;
            font-size: 1rem;
            cursor: pointer;
            padding: 0.5rem;
            transition: transform 0.3s ease;
        }
        
        .approval-item.expanded .approval-expand-btn {
            transform: rotate(180deg);
        }
        
        .approval-details {
            display: none;
            padding: 0 1.25rem 1.25rem;
            border-top: 1px solid rgba(0, 0, 0, 0.08);
            animation: slideDown 0.3s ease;
        }
        
        .approval-item.expanded .approval-details {
            display: block;
        }
        
        @keyframes slideDown {
            from { opacity: 0; max-height: 0; }
            to { opacity: 1; max-height: 500px; }
        }
        
        .approval-description {
            padding: 1rem 0;
            color: #4B5563;
            line-height: 1.6;
        }
        
        .approval-path {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem;
            background: rgba(41, 171, 226, 0.05);
            border-radius: 8px;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            font-size: 0.9rem;
        }
        
        .path-node {
            padding: 0.25rem 0.75rem;
            background: white;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 6px;
        }
        
        .path-arrow {
            color: #9CA3AF;
        }
        
        .approval-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            padding-top: 1rem;
            border-top: 1px solid rgba(0, 0, 0, 0.08);
        }
        
        .approval-actions .action-btn {
            flex: 1;
            min-width: 100px;
            justify-content: center;
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }
        
        .action-btn.escalate {
            background: rgba(245, 158, 11, 0.1);
            color: #D97706;
        }
        
        .action-btn.escalate:hover {
            background: #F59E0B;
            color: white;
        }
        
        .action-btn.archive {
            background: rgba(107, 114, 128, 0.1);
            color: #6B7280;
        }
        
        .action-btn.archive:hover {
            background: #6B7280;
            color: white;
        }
        
        .action-btn.restore {
            background: rgba(16, 185, 129, 0.1);
            color: #059669;
        }
        
        .action-btn.restore:hover {
            background: #10B981;
            color: white;
        }
        
        /* Announcement Moderation Specific */
        .announcement-card {
            background: #FAFAFA;
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 12px;
            padding: 1.25rem;
            transition: all 0.3s ease;
        }
        
        .announcement-card:hover {
            border-color: var(--admin-accent);
        }
        
        .announcement-card.urgent {
            border-left: 4px solid #EF4444;
        }
        
        .announcement-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .announcement-card-title {
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            color: #1F2933;
        }
        
        .announcement-badges {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .scope-badge {
            padding: 0.25rem 0.5rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .scope-badge.global { background: rgba(139, 92, 246, 0.1); color: #7C3AED; }
        .scope-badge.org { background: rgba(41, 171, 226, 0.1); color: var(--admin-accent); }
        .scope-badge.node { background: rgba(16, 185, 129, 0.1); color: #059669; }
        
        .verified-badge {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            background: rgba(16, 185, 129, 0.1);
            color: #059669;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .announcement-card-content {
            color: #4B5563;
            margin-bottom: 1rem;
            line-height: 1.5;
        }
        
        .announcement-card-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .deadline-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            color: #6B7280;
        }
        
        .deadline-info.expiring-soon {
            color: #EF4444;
        }
        
        .announcement-card-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        /* Escalation Tabs */
        .escalation-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            padding-bottom: 0.5rem;
        }
        
        .esc-tab {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.5rem 1rem;
            background: transparent;
            border: none;
            border-radius: 8px 8px 0 0;
            font-size: 0.9rem;
            font-weight: 500;
            color: #6B7280;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .esc-tab:hover {
            color: var(--admin-accent);
        }
        
        .esc-tab.active {
            color: var(--admin-accent);
            border-bottom: 2px solid var(--admin-accent);
        }
        
        .escalation-content {
            display: none;
        }
        
        .escalation-content.active {
            display: block;
        }
        
        /* Escalation Item */
        .escalation-item {
            background: #FAFAFA;
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-left: 4px solid #F59E0B;
            border-radius: 0 12px 12px 0;
            padding: 1.25rem;
            margin-bottom: 1rem;
            transition: all 0.3s ease;
        }
        
        .escalation-item:hover {
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.15);
        }
        
        .escalation-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .escalation-title {
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            color: #1F2933;
        }
        
        .escalation-reason {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.35rem 0.75rem;
            background: rgba(245, 158, 11, 0.1);
            color: #D97706;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        .escalation-path-trail {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem;
            background: rgba(245, 158, 11, 0.05);
            border-radius: 8px;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            font-size: 0.85rem;
            animation: trailReveal 0.5s ease;
        }
        
        @keyframes trailReveal {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .trail-node {
            padding: 0.25rem 0.75rem;
            background: white;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 6px;
        }
        
        .trail-node.current {
            background: #F59E0B;
            color: white;
            border-color: #F59E0B;
            animation: pulse-node 2s infinite;
        }
        
        @keyframes pulse-node {
            0%, 100% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.4); }
            50% { box-shadow: 0 0 0 8px rgba(245, 158, 11, 0); }
        }
        
        .escalation-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .action-btn.send-back {
            background: rgba(139, 92, 246, 0.1);
            color: #7C3AED;
        }
        
        .action-btn.send-back:hover {
            background: #7C3AED;
            color: white;
        }
        
        .action-btn.force-escalate {
            background: rgba(236, 72, 153, 0.1);
            color: #DB2777;
        }
        
        .action-btn.force-escalate:hover {
            background: #DB2777;
            color: white;
        }
        
        /* Archive Item */
        .archive-item {
            background: #FAFAFA;
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 12px;
            padding: 1.25rem;
            margin-bottom: 1rem;
            opacity: 0.85;
            transition: all 0.3s ease;
        }
        
        .archive-item:hover {
            opacity: 1;
            border-color: #6B7280;
        }
        
        .archive-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.5rem;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .archive-title {
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            color: #6B7280;
        }
        
        .archive-reason {
            font-size: 0.85rem;
            color: #9CA3AF;
            margin-bottom: 0.75rem;
        }
        
        .archive-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        /* Empty State */
        .governance-empty {
            text-align: center;
            padding: 3rem;
            color: #6B7280;
        }
        
        .governance-empty i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }
        
        .governance-empty h3 {
            font-family: 'Poppins', sans-serif;
            margin-bottom: 0.5rem;
            color: #1F2933;
        }
        
        /* Success Ripple Animation */
        .approval-success-ripple {
            position: relative;
            overflow: hidden;
        }
        
        .approval-success-ripple::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(16, 185, 129, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: ripple 0.6s ease-out;
        }
        
        @keyframes ripple {
            to {
                width: 200%;
                height: 200%;
                opacity: 0;
            }
        }
        
        /* Toggle Label */
        .toggle-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: #6B7280;
            cursor: pointer;
        }
        
        .toggle-label input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--admin-accent);
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .governance-tabs {
                flex-direction: column;
            }
            
            .gov-tab {
                justify-content: center;
            }
            
            .panel-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .panel-filters {
                width: 100%;
                justify-content: flex-start;
            }
            
            .approval-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .approval-actions {
                flex-direction: column;
            }
            
            .approval-actions .action-btn {
                width: 100%;
            }
        }
    </style>

    <!-- Details Modal -->
    <div class="modal-overlay" id="detailsModal">
        <div class="modal">
            <div class="modal-header"><h2 class="modal-title" id="modalTitle">Details</h2><button class="modal-close" onclick="closeModal('detailsModal')">&times;</button></div>
            <div class="modal-body" id="modalContent"></div>
            <div class="modal-footer"><button class="btn-secondary" onclick="closeModal('detailsModal')">Close</button></div>
        </div>
    </div>
    <!-- Reject Reason Modal -->
    <div class="modal-overlay" id="rejectModal">
        <div class="modal">
            <div class="modal-header"><h2 class="modal-title">Reject Request</h2><button class="modal-close" onclick="closeModal('rejectModal')">&times;</button></div>
            <div class="modal-body">
                <p style="margin-bottom:1rem;">Rejecting request from: <strong id="rejectRequester"></strong></p>
                <div class="form-group"><label class="form-label">Rejection Reason (optional)</label><textarea class="form-input" id="rejectReason" rows="3" placeholder="Enter reason for rejection..."></textarea></div>
            </div>
            <div class="modal-footer"><button class="btn-secondary" onclick="closeModal('rejectModal')">Cancel</button><button class="btn-primary" style="background:linear-gradient(135deg, #EF4444, #DC2626);" id="confirmRejectBtn">Reject</button></div>
        </div>
    </div>
    <!-- Add Sub-Node Modal -->
    <div class="modal-overlay" id="addSubnodeModal">
        <div class="modal">
            <div class="modal-header"><h2 class="modal-title" id="subnodeModalTitle">Add Sub-Node</h2><button class="modal-close" onclick="closeModal('addSubnodeModal')">&times;</button></div>
            <div class="modal-body">
                <div class="form-group"><label class="form-label">Parent Node</label><select class="form-input" id="parentNodeSelect"></select></div>
                <div class="form-group"><label class="form-label">Name</label><input type="text" class="form-input" id="subnodeName" placeholder="Enter sub-node name"></div>
                <div class="form-group"><label class="form-label">Type</label><select class="form-input" id="subnodeType"><option value="department">Department</option><option value="team">Team</option><option value="project">Project</option><option value="academic">Academic</option><option value="hostel">Hostel</option><option value="sports">Sports</option><option value="club">Club</option></select></div>
            </div>
            <div class="modal-footer"><button class="btn-secondary" onclick="closeModal('addSubnodeModal')">Cancel</button><button class="btn-primary" id="saveSubnodeBtn">Save</button></div>
        </div>
    </div>
    <!-- Assign Node Admin Modal -->
    <div class="modal-overlay" id="assignNodeAdminModal">
        <div class="modal">
            <div class="modal-header"><h2 class="modal-title">Assign Node Admin</h2><button class="modal-close" onclick="closeModal('assignNodeAdminModal')">&times;</button></div>
            <div class="modal-body">
                <p style="margin-bottom:1rem;">Assign admin to: <strong id="assignNodeName"></strong></p>
                <div class="form-group"><label class="form-label">Admin Email</label><input type="email" class="form-input" id="nodeAdminEmail" placeholder="admin@example.com"></div>
            </div>
            <div class="modal-footer"><button class="btn-secondary" onclick="closeModal('assignNodeAdminModal')">Cancel</button><button class="btn-primary" id="confirmAssignNodeAdminBtn">Assign</button></div>
        </div>
    </div>
    <div class="toast" id="toast"><i class="fas fa-check-circle" style="color:#10B981;"></i><span id="toastMessage">Success!</span></div>

    <!-- Governance Action Modal - Reject with Reason -->
    <div class="modal-overlay" id="govRejectModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title"><i class="fas fa-times-circle" style="color:#EF4444;margin-right:0.5rem;"></i>Reject Item</h2>
                <button class="modal-close" onclick="closeModal('govRejectModal')">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom:1rem;">Rejecting: <strong id="govRejectItemTitle"></strong></p>
                <div class="form-group">
                    <label class="form-label">Rejection Reason <span style="color:#EF4444;">*</span></label>
                    <textarea class="form-input" id="govRejectReason" rows="3" placeholder="Please provide a reason for rejection..." required></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeModal('govRejectModal')">Cancel</button>
                <button class="btn-primary" style="background:linear-gradient(135deg, #EF4444, #DC2626);" id="confirmGovRejectBtn">Reject</button>
            </div>
        </div>
    </div>

    <!-- Governance Action Modal - Escalate -->
    <div class="modal-overlay" id="govEscalateModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title"><i class="fas fa-level-up-alt" style="color:#F59E0B;margin-right:0.5rem;"></i>Escalate Item</h2>
                <button class="modal-close" onclick="closeModal('govEscalateModal')">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom:1rem;">Escalating: <strong id="govEscalateItemTitle"></strong></p>
                <div class="form-group">
                    <label class="form-label">Escalate To</label>
                    <select class="form-input" id="govEscalateTo">
                        <option value="parent">Parent Node Admin</option>
                        <option value="org">Organization Admin</option>
                        <option value="platform">Platform Admin (Super Admin)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Escalation Reason</label>
                    <textarea class="form-input" id="govEscalateReason" rows="3" placeholder="Why is this being escalated?"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeModal('govEscalateModal')">Cancel</button>
                <button class="btn-primary" style="background:linear-gradient(135deg, #F59E0B, #D97706);" id="confirmGovEscalateBtn">Escalate</button>
            </div>
        </div>
    </div>

    <!-- Governance Action Modal - Archive -->
    <div class="modal-overlay" id="govArchiveModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title"><i class="fas fa-archive" style="color:#6B7280;margin-right:0.5rem;"></i>Archive Item</h2>
                <button class="modal-close" onclick="closeModal('govArchiveModal')">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom:1rem;">Archiving: <strong id="govArchiveItemTitle"></strong></p>
                <div class="form-group">
                    <label class="form-label">Archive Reason</label>
                    <textarea class="form-input" id="govArchiveReason" rows="3" placeholder="Why is this being archived?"></textarea>
                </div>
                <p style="font-size:0.85rem;color:#6B7280;"><i class="fas fa-info-circle"></i> Archived items can be restored by admins later.</p>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeModal('govArchiveModal')">Cancel</button>
                <button class="btn-primary" style="background:linear-gradient(135deg, #6B7280, #4B5563);" id="confirmGovArchiveBtn">Archive</button>
            </div>
        </div>
    </div>

    <!-- Governance Action Modal - Edit Announcement -->
    <div class="modal-overlay" id="govEditAnnouncementModal">
        <div class="modal" style="max-width:600px;">
            <div class="modal-header">
                <h2 class="modal-title"><i class="fas fa-edit" style="color:var(--admin-accent);margin-right:0.5rem;"></i>Edit Announcement</h2>
                <button class="modal-close" onclick="closeModal('govEditAnnouncementModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Title</label>
                    <input type="text" class="form-input" id="editAnnouncementTitle" placeholder="Announcement title">
                </div>
                <div class="form-group">
                    <label class="form-label">Content</label>
                    <textarea class="form-input" id="editAnnouncementContent" rows="4" placeholder="Announcement content"></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Expiry Date</label>
                    <input type="date" class="form-input" id="editAnnouncementExpiry">
                </div>
                <div class="form-group">
                    <label class="form-label">Visibility Scope</label>
                    <select class="form-input" id="editAnnouncementScope">
                        <option value="node">Node Only</option>
                        <option value="org">Organization Wide</option>
                        <option value="global">Global</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="toggle-label">
                        <input type="checkbox" id="editAnnouncementVerified">
                        Mark as Verified
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeModal('govEditAnnouncementModal')">Cancel</button>
                <button class="btn-primary" id="confirmEditAnnouncementBtn">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Governance Confirmation Modal -->
    <div class="modal-overlay" id="govConfirmModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title" id="govConfirmTitle">Confirm Action</h2>
                <button class="modal-close" onclick="closeModal('govConfirmModal')">&times;</button>
            </div>
            <div class="modal-body">
                <p id="govConfirmMessage">Are you sure you want to proceed?</p>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeModal('govConfirmModal')">Cancel</button>
                <button class="btn-primary" id="confirmGovActionBtn">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Branch Merge Modal -->
    <div class="modal-overlay" id="branchMergeModal">
        <div class="modal">
            <div class="modal-header"><h2 class="modal-title">Merge Branch Request</h2><button class="modal-close" onclick="closeModal('branchMergeModal')">&times;</button></div>
            <div class="modal-body">
                <p style="margin-bottom:1rem;">Merging branch request: <strong id="mergeBranchName"></strong></p>
                <p style="margin-bottom:1rem; color:#6B7280; font-size:0.9rem;">Requested by: <span id="mergeBranchRequester"></span></p>
                <div class="form-group">
                    <label class="form-label">Select Existing Sub-Node to Merge Into</label>
                    <select class="form-input" id="mergeBranchTarget">
                        <option value="">-- Select a sub-node --</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Name Handling</label>
                    <select class="form-input" id="mergeBranchNameOption">
                        <option value="alias">Retain as Alias (recommended)</option>
                        <option value="vanish">Vanish Name</option>
                    </select>
                    <p class="form-hint">Alias: Future users typing this name will be redirected to the target node.</p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeModal('branchMergeModal')">Cancel</button>
                <button class="btn-primary" id="confirmBranchMergeBtn" style="background:linear-gradient(135deg, #8B5CF6, #A78BFA);">Merge</button>
            </div>
        </div>
    </div>

    <!-- Restructure Modal -->
    <div class="modal-overlay" id="restructureModal">
        <div class="modal" style="max-width: 600px;">
            <div class="modal-header"><h2 class="modal-title">Restructure Branch</h2><button class="modal-close" onclick="closeModal('restructureModal')">&times;</button></div>
            <div class="modal-body">
                <p style="margin-bottom:1rem;">Insert a missing intermediate node between parent and the requested branch.</p>
                <p style="margin-bottom:1rem; color:#6B7280; font-size:0.9rem;">Original request: <strong id="restructureOriginalName"></strong> by <span id="restructureRequester"></span></p>
                
                <div class="form-group">
                    <label class="form-label">Missing Intermediate Node Name</label>
                    <input type="text" class="form-input" id="restructureMiddleName" placeholder="e.g., CSE, Engineering, etc.">
                    <p class="form-hint">This node will be created between the parent and the requested node.</p>
                </div>
                <div class="form-group">
                    <label class="form-label">Intermediate Node Type</label>
                    <select class="form-input" id="restructureMiddleType">
                        <option value="department">Department</option>
                        <option value="team">Team</option>
                        <option value="project">Project</option>
                        <option value="academic">Academic</option>
                        <option value="hostel">Hostel</option>
                        <option value="sports">Sports</option>
                        <option value="club">Club</option>
                    </select>
                </div>
                
                <div class="restructure-preview" id="restructurePreview" style="display:none;">
                    <div class="preview-title">New Structure Preview:</div>
                    <div class="preview-path" id="restructurePreviewPath"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeModal('restructureModal')">Cancel</button>
                <button class="btn-primary" id="confirmRestructureBtn" style="background:linear-gradient(135deg, #EC4899, #F472B6);">Restructure</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, onAuthStateChanged, signOut } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFirestore, collection, getDocs, doc, getDoc, setDoc, deleteDoc, query, where, serverTimestamp, arrayUnion, arrayRemove, addDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        const firebaseConfig = {
            apiKey: "AIzaSyBsuZL4U2H66C9tUKN91KXMm-l5umOa1vY",
            authDomain: "flowlinkkiro.firebaseapp.com",
            projectId: "flowlinkkiro",
            storageBucket: "flowlinkkiro.firebasestorage.app",
            messagingSenderId: "918596906932",
            appId: "1:918596906932:web:55e2a235cefedd61098ce1",
            measurementId: "G-B32FNF648G"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let currentUser = null;
        let adminOrganizations = [];
        let adminNodes = []; // Node-level admin access
        let selectedOrgId = null;
        let selectedNodePath = null; // For node-level admins
        let isNodeAdmin = false; // Flag to indicate node-level admin
        let allProblems = [];
        let allAnnouncements = [];
        let joinRequests = [];
        let branchRequests = [];
        let subNodes = [];
        let currentRejectRequest = null;
        let currentAssignNode = null;

        onAuthStateChanged(auth, async (user) => {
            if (!user) { window.location.href = 'login.html'; return; }
            currentUser = user;
            document.getElementById('adminDisplayName').textContent = user.email;
            await checkAdminStatus();
        });

        async function checkAdminStatus() {
            try {
                const userEmail = currentUser.email;
                const hierarchiesRef = collection(db, 'hierarchies');
                const snapshot = await getDocs(hierarchiesRef);
                adminOrganizations = [];
                adminNodes = [];
                
                // Check for organization-level admin access
                for (const docSnap of snapshot.docs) {
                    const data = docSnap.data();
                    if (data.adminEmails && data.adminEmails.includes(userEmail)) {
                        adminOrganizations.push({ id: docSnap.id, ...data, adminLevel: 'organization' });
                    }
                    
                    // Check for node-level admin access within this org
                    const nodeAdminAccess = await checkNodeAdminAccess(docSnap.id, userEmail);
                    if (nodeAdminAccess.length > 0) {
                        nodeAdminAccess.forEach(node => {
                            adminNodes.push({
                                orgId: docSnap.id,
                                orgName: data.name,
                                ...node,
                                adminLevel: 'node'
                            });
                        });
                    }
                }
                
                document.getElementById('loadingSpinner').style.display = 'none';
                
                // Check if user has any admin access (org or node level)
                if (adminOrganizations.length === 0 && adminNodes.length === 0) { 
                    document.getElementById('notAdminMessage').style.display = 'block'; 
                    return; 
                }
                
                document.getElementById('adminContentWrapper').style.display = 'block';
                
                // Build org selector with both org-level and node-level admin access
                const orgSelect = document.getElementById('orgSelect');
                let options = '';
                
                // Add organization-level admin options
                adminOrganizations.forEach(org => {
                    options += `<option value="org:${org.id}">${org.name} (Organization Admin)</option>`;
                });
                
                // Add node-level admin options
                adminNodes.forEach(node => {
                    options += `<option value="node:${node.orgId}:${node.path}">${node.orgName}  ${node.name} (Node Admin)</option>`;
                });
                
                orgSelect.innerHTML = options;
                
                // Set initial selection
                if (adminOrganizations.length > 0) {
                    selectedOrgId = adminOrganizations[0].id;
                    selectedNodePath = null;
                    isNodeAdmin = false;
                } else if (adminNodes.length > 0) {
                    selectedOrgId = adminNodes[0].orgId;
                    selectedNodePath = adminNodes[0].path;
                    isNodeAdmin = true;
                }
                
                orgSelect.addEventListener('change', (e) => { 
                    const value = e.target.value;
                    if (value.startsWith('org:')) {
                        selectedOrgId = value.replace('org:', '');
                        selectedNodePath = null;
                        isNodeAdmin = false;
                    } else if (value.startsWith('node:')) {
                        const parts = value.split(':');
                        selectedOrgId = parts[1];
                        selectedNodePath = parts.slice(2).join(':');
                        isNodeAdmin = true;
                    }
                    updateAdminBadge();
                    loadOrganizationData(); 
                });
                
                updateAdminBadge();
                setupNavigation();
                setupEventListeners();
                await loadOrganizationData();
            } catch (error) { 
                console.error('Error checking admin status:', error); 
                showToast('Error loading admin data: ' + error.message, 'error'); 
            }
        }
        
        // Check for node-level admin access within an organization
        async function checkNodeAdminAccess(orgId, userEmail) {
            const nodeAdminAccess = [];
            
            async function checkNodesRecursive(parentPath) {
                try {
                    const subNodesRef = collection(db, parentPath, 'sub-nodes');
                    const snapshot = await getDocs(subNodesRef);
                    
                    for (const docSnap of snapshot.docs) {
                        const data = docSnap.data();
                        const nodePath = `${parentPath}/sub-nodes/${docSnap.id}`;
                        
                        if (data.adminEmails && data.adminEmails.includes(userEmail)) {
                            nodeAdminAccess.push({
                                id: docSnap.id,
                                path: nodePath,
                                name: data.name,
                                type: data.type || 'department',
                                ...data
                            });
                        }
                        
                        // Check children
                        await checkNodesRecursive(nodePath);
                    }
                } catch (e) {
                    // No sub-nodes
                }
            }
            
            await checkNodesRecursive(`hierarchies/${orgId}`);
            return nodeAdminAccess;
        }
        
        // Update admin badge based on admin level
        function updateAdminBadge() {
            const badge = document.querySelector('.topbar-badge');
            const roleText = document.querySelector('.admin-role');
            const membersSectionTitle = document.querySelector('#membersPage .section-title');
            const subnodesSectionTitle = document.querySelector('#subnodesPage .section-title');
            
            if (isNodeAdmin) {
                badge.textContent = 'Node Admin';
                badge.style.background = 'linear-gradient(135deg, #8B5CF6, #A78BFA)';
                roleText.textContent = 'Node Admin';
                if (membersSectionTitle) membersSectionTitle.textContent = 'Node Members';
                if (subnodesSectionTitle) subnodesSectionTitle.textContent = 'Sub-Nodes (Your Scope)';
            } else {
                badge.textContent = 'Organization Admin';
                badge.style.background = 'linear-gradient(135deg, var(--admin-accent), #29E2D0)';
                roleText.textContent = 'Organization Admin';
                if (membersSectionTitle) membersSectionTitle.textContent = 'Organization Members';
                if (subnodesSectionTitle) subnodesSectionTitle.textContent = 'Sub-Nodes Management';
            }
        }

        function setupNavigation() {
            const pageMap = { 'dashboard': 'dashboardPage', 'join-requests': 'joinRequestsPage', 'branch-requests': 'branchRequestsPage', 'subnodes': 'subnodesPage', 'members': 'membersPage', 'problems': 'problemsPage', 'announcements': 'announcementsPage' };
            const titles = { 'dashboard': 'Admin Dashboard', 'join-requests': 'Join Requests', 'branch-requests': 'Branch Requests', 'subnodes': 'Sub-Nodes', 'members': 'Members', 'problems': 'Problems', 'announcements': 'Announcements' };
            document.querySelectorAll('.nav-item').forEach(item => {
                item.addEventListener('click', () => {
                    const page = item.dataset.page;
                    document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
                    item.classList.add('active');
                    document.querySelectorAll('.page-section').forEach(s => s.classList.remove('active'));
                    document.getElementById(pageMap[page]).classList.add('active');
                    document.getElementById('pageTitle').textContent = titles[page];
                    closeMobileMenu();
                });
            });
        }

        function setupEventListeners() {
            document.getElementById('signOutBtn').addEventListener('click', async () => { await signOut(auth); window.location.href = 'login.html'; });
            document.getElementById('backToDashboardBtn').addEventListener('click', () => { window.location.href = 'dashboard.html'; });
            document.getElementById('mobileMenuBtn').addEventListener('click', toggleMobileMenu);
            document.getElementById('mobileOverlay').addEventListener('click', closeMobileMenu);
            document.getElementById('addSubnodeBtn').addEventListener('click', openAddSubnodeModal);
            document.getElementById('saveSubnodeBtn').addEventListener('click', saveSubnode);
            document.getElementById('confirmRejectBtn').addEventListener('click', confirmReject);
            document.getElementById('confirmAssignNodeAdminBtn').addEventListener('click', confirmAssignNodeAdmin);
        }

        function toggleMobileMenu() { document.getElementById('adminSidebar').classList.toggle('show'); document.getElementById('mobileOverlay').classList.toggle('show'); }
        function closeMobileMenu() { document.getElementById('adminSidebar').classList.remove('show'); document.getElementById('mobileOverlay').classList.remove('show'); }

        async function loadOrganizationData() {
            const org = adminOrganizations.find(o => o.id === selectedOrgId);
            
            // For node admins, get member count from their managed node
            if (isNodeAdmin && selectedNodePath) {
                try {
                    const nodeDoc = await getDoc(doc(db, selectedNodePath));
                    if (nodeDoc.exists()) {
                        const nodeData = nodeDoc.data();
                        document.getElementById('totalMembers').textContent = (nodeData.members || []).length;
                    } else {
                        document.getElementById('totalMembers').textContent = 0;
                    }
                } catch (e) {
                    document.getElementById('totalMembers').textContent = 0;
                }
            } else if (org) {
                document.getElementById('totalMembers').textContent = (org.members || []).length;
            }
            
            await Promise.all([loadJoinRequests(), loadBranchRequests(), loadSubNodes(), loadProblems(org), loadAnnouncements(org)]);
            updateBadges();
            renderAllSections(org);
            
            // Load governance data after org data is loaded
            await initGovernanceData();
            setupGovernanceTabs();
        }

        async function loadJoinRequests() {
            try {
                // First, try to load from admin's notifications for faster lookup
                const notifRef = doc(db, 'users', currentUser.email, 'notifications', 'pending');
                const notifDoc = await getDoc(notifRef);
                
                let joinRequestIds = [];
                if (notifDoc.exists()) {
                    joinRequestIds = notifDoc.data().joinRequests || [];
                }
                
                console.log('Join request IDs from notifications:', joinRequestIds);
                
                // Fetch the actual join requests from notifications
                joinRequests = [];
                for (const requestId of joinRequestIds) {
                    try {
                        const requestDoc = await getDoc(doc(db, 'pendingApprovals', requestId));
                        if (requestDoc.exists()) {
                            const data = requestDoc.data();
                            // Only include if still pending
                            if (data.status === 'pending') {
                                // For node admins, only show requests for their node and below
                                if (isNodeAdmin && selectedNodePath) {
                                    // Check if target node is under the managed node
                                    if (data.targetNodePath && data.targetNodePath.startsWith(selectedNodePath)) {
                                        joinRequests.push({ id: requestDoc.id, ...data });
                                    }
                                } else {
                                    // Org admin - show all requests for this org
                                    if (data.targetOrgId === selectedOrgId || 
                                        (data.targetNodePath && data.targetNodePath.startsWith(`hierarchies/${selectedOrgId}`))) {
                                        joinRequests.push({ id: requestDoc.id, ...data });
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.log('Request not found:', requestId);
                    }
                }
                
                // FALLBACK: Also scan pendingApprovals for any requests assigned to this admin
                if (joinRequests.length === 0) {
                    console.log('No requests from notifications, checking pendingApprovals directly...');
                    const pendingRef = collection(db, 'pendingApprovals');
                    const snapshot = await getDocs(pendingRef);
                    
                    snapshot.docs.forEach(docSnap => {
                        const data = docSnap.data();
                        if (data.requestType === 'join' && 
                            data.status === 'pending' &&
                            data.assignedAdminEmail === currentUser.email) {
                            
                            // For node admins, only show requests for their node and below
                            if (isNodeAdmin && selectedNodePath) {
                                if (data.targetNodePath && data.targetNodePath.startsWith(selectedNodePath)) {
                                    joinRequests.push({ id: docSnap.id, ...data });
                                }
                            } else {
                                // Org admin - show all requests for this org
                                if (data.targetOrgId === selectedOrgId || 
                                    (data.targetNodePath && data.targetNodePath.startsWith(`hierarchies/${selectedOrgId}`))) {
                                    joinRequests.push({ id: docSnap.id, ...data });
                                }
                            }
                        }
                    });
                }
                
                console.log('Total join requests:', joinRequests.length);
                document.getElementById('joinRequestCount').textContent = joinRequests.length;
            } catch (error) { 
                console.error('Error loading join requests:', error); 
                joinRequests = []; 
            }
        }

        async function loadBranchRequests() {
            try {
                // First, try to load from admin's notifications for faster lookup
                const notifRef = doc(db, 'users', currentUser.email, 'notifications', 'pending');
                const notifDoc = await getDoc(notifRef);
                
                let branchRequestIds = [];
                if (notifDoc.exists()) {
                    branchRequestIds = notifDoc.data().branchRequests || [];
                }
                
                console.log('Branch request IDs from notifications:', branchRequestIds);
                
                // Fetch the actual branch requests from notifications
                branchRequests = [];
                for (const requestId of branchRequestIds) {
                    try {
                        const requestDoc = await getDoc(doc(db, 'pendingApprovals', requestId));
                        if (requestDoc.exists()) {
                            const data = requestDoc.data();
                            // Only include if still pending
                            if (data.status === 'pending') {
                                // For node admins, only show requests for their node and below
                                if (isNodeAdmin && selectedNodePath) {
                                    // Check if parent node is the managed node or under it
                                    if (data.parentNodePath && (data.parentNodePath === selectedNodePath || data.parentNodePath.startsWith(selectedNodePath + '/sub-nodes/'))) {
                                        branchRequests.push({ id: requestDoc.id, ...data });
                                    }
                                } else {
                                    // Org admin - show all requests for this org
                                    if (data.parentOrgId === selectedOrgId || 
                                        (data.parentNodePath && data.parentNodePath.startsWith(`hierarchies/${selectedOrgId}`))) {
                                        branchRequests.push({ id: requestDoc.id, ...data });
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.log('Request not found:', requestId);
                    }
                }
                
                // FALLBACK: Also scan pendingApprovals for any requests assigned to this admin
                if (branchRequests.length === 0) {
                    console.log('No requests from notifications, checking pendingApprovals directly...');
                    const pendingRef = collection(db, 'pendingApprovals');
                    const snapshot = await getDocs(pendingRef);
                    
                    snapshot.docs.forEach(docSnap => {
                        const data = docSnap.data();
                        if (data.requestType === 'branch' && 
                            data.status === 'pending' &&
                            data.assignedAdminEmail === currentUser.email) {
                            
                            // For node admins, only show requests for their node and below
                            if (isNodeAdmin && selectedNodePath) {
                                if (data.parentNodePath && (data.parentNodePath === selectedNodePath || data.parentNodePath.startsWith(selectedNodePath + '/sub-nodes/'))) {
                                    branchRequests.push({ id: docSnap.id, ...data });
                                }
                            } else {
                                // Org admin - show all requests for this org
                                if (data.parentOrgId === selectedOrgId || 
                                    (data.parentNodePath && data.parentNodePath.startsWith(`hierarchies/${selectedOrgId}`))) {
                                    branchRequests.push({ id: docSnap.id, ...data });
                                }
                            }
                        }
                    });
                }
                
                console.log('Total branch requests:', branchRequests.length);
                document.getElementById('branchRequestCount').textContent = branchRequests.length;
            } catch (error) { 
                console.error('Error loading branch requests:', error); 
                branchRequests = []; 
            }
        }

        async function loadSubNodes() {
            try {
                subNodes = [];
                
                if (isNodeAdmin && selectedNodePath) {
                    // Node admin - only load sub-nodes under their managed node
                    const nodeRef = doc(db, selectedNodePath);
                    const nodeDoc = await getDoc(nodeRef);
                    
                    if (nodeDoc.exists()) {
                        const nodeData = nodeDoc.data();
                        // Add the managed node itself at level 0
                        subNodes.push({ 
                            id: selectedNodePath.split('/').pop(), 
                            path: selectedNodePath, 
                            level: 0, 
                            isManaged: true,
                            ...nodeData 
                        });
                        
                        // Load children under this node
                        const subNodesRef = collection(nodeRef, 'sub-nodes');
                        await fetchSubNodesRecursive(subNodesRef, selectedNodePath, 1);
                    }
                } else {
                    // Organization admin - load all sub-nodes
                    const orgRef = doc(db, 'hierarchies', selectedOrgId);
                    const subNodesRef = collection(orgRef, 'sub-nodes');
                    await fetchSubNodesRecursive(subNodesRef, `hierarchies/${selectedOrgId}`, 0);
                }
            } catch (error) { 
                console.error('Error loading sub-nodes:', error); 
                subNodes = []; 
            }
        }

        async function fetchSubNodesRecursive(colRef, parentPath, level) {
            try {
                const snapshot = await getDocs(colRef);
                for (const docSnap of snapshot.docs) {
                    const data = docSnap.data();
                    const nodePath = `${parentPath}/sub-nodes/${docSnap.id}`;
                    subNodes.push({ id: docSnap.id, path: nodePath, level, ...data });
                    const childrenRef = collection(docSnap.ref, 'sub-nodes');
                    await fetchSubNodesRecursive(childrenRef, nodePath, level + 1);
                }
            } catch (e) { /* No children */ }
        }

        async function loadProblems(org) {
            try {
                const problemsRef = collection(db, 'problems');
                const snapshot = await getDocs(problemsRef);
                allProblems = snapshot.docs.map(d => ({ id: d.id, ...d.data() }))
                    .filter(p => p.organizationId === org.id || (org.members && org.members.includes(p.createdBy)));
                document.getElementById('totalProblems').textContent = allProblems.filter(p => p.status !== 'solved').length;
                document.getElementById('solvedProblems').textContent = allProblems.filter(p => p.status === 'solved').length;
            } catch (error) { console.error('Error loading problems:', error); allProblems = []; }
        }

        async function loadAnnouncements(org) {
            try {
                const announcementsRef = collection(db, 'announcements');
                const snapshot = await getDocs(announcementsRef);
                allAnnouncements = snapshot.docs.map(d => ({ id: d.id, ...d.data() }))
                    .filter(a => a.organizationId === org.id || (org.members && org.members.includes(a.createdBy)));
            } catch (error) { console.error('Error loading announcements:', error); allAnnouncements = []; }
        }

        function updateBadges() {
            const joinBadge = document.getElementById('joinBadge');
            const branchBadge = document.getElementById('branchBadge');
            if (joinRequests.length > 0) { joinBadge.textContent = joinRequests.length; joinBadge.style.display = 'inline'; }
            else { joinBadge.style.display = 'none'; }
            if (branchRequests.length > 0) { branchBadge.textContent = branchRequests.length; branchBadge.style.display = 'inline'; }
            else { branchBadge.style.display = 'none'; }
        }

        function renderAllSections(org) {
            renderRecentActivity();
            renderJoinRequests();
            renderBranchRequests();
            renderSubNodes();
            renderMembers(org); // Now async but we don't need to await
            renderProblems();
            renderAnnouncements();
        }

        function renderRecentActivity() {
            const container = document.getElementById('recentActivityTable');
            const recentItems = [...joinRequests.map(r => ({...r, itemType: 'join'})), ...branchRequests.map(r => ({...r, itemType: 'branch'})), ...allProblems.slice(0, 3)]
                .sort((a, b) => (b.createdAt?.seconds || 0) - (a.createdAt?.seconds || 0)).slice(0, 5);
            if (recentItems.length === 0) { container.innerHTML = '<div class="empty-state"><i class="fas fa-inbox"></i><h3>No Recent Activity</h3><p>Activity will appear here.</p></div>'; return; }
            container.innerHTML = `<table><thead><tr><th>Type</th><th>Details</th><th>From</th><th>Date</th><th>Status</th></tr></thead><tbody>${recentItems.map(item => `<tr>
                <td><span class="status-badge ${item.itemType || (item.priority ? 'high' : 'pending')}">${item.itemType === 'join' ? 'Join Request' : item.itemType === 'branch' ? 'Branch Request' : 'Problem'}</span></td>
                <td><strong>${item.targetNodeName || item.proposedName || item.title || 'N/A'}</strong></td>
                <td>${item.requesterEmail || item.createdBy || 'Unknown'}</td>
                <td>${item.createdAt ? new Date(item.createdAt.seconds * 1000).toLocaleDateString() : 'N/A'}</td>
                <td><span class="status-badge ${item.status || 'pending'}">${item.status || 'pending'}</span></td>
            </tr>`).join('')}</tbody></table>`;
        }

        function renderJoinRequests() {
            const container = document.getElementById('joinRequestsTable');
            if (joinRequests.length === 0) { container.innerHTML = '<div class="empty-state"><i class="fas fa-user-plus"></i><h3>No Pending Join Requests</h3><p>All join requests have been processed.</p></div>'; return; }
            container.innerHTML = `<table><thead><tr><th>Requester</th><th>Target Node</th><th>Source</th><th>Date</th><th>Actions</th></tr></thead><tbody>${joinRequests.map(r => `<tr>
                <td><strong>${r.requesterEmail}</strong></td>
                <td>${r.targetNodeName || 'Organization Root'}</td>
                <td>${r.mergedFrom ? `<span style="color:#8B5CF6;font-size:0.85rem;"><i class="fas fa-code-merge"></i> Merged from "${r.mergedFrom}"</span>` : '<span style="color:#6B7280;font-size:0.85rem;">Direct request</span>'}</td>
                <td>${r.createdAt ? new Date(r.createdAt.seconds * 1000).toLocaleDateString() : 'N/A'}</td>
                <td><button class="action-btn approve" onclick="approveJoinRequest('${r.id}')">Approve</button><button class="action-btn reject" onclick="openRejectModal('${r.id}', 'join', '${r.requesterEmail}')">Reject</button></td>
            </tr>`).join('')}</tbody></table>`;
        }

        function renderBranchRequests() {
            const container = document.getElementById('branchRequestsTable');
            if (branchRequests.length === 0) { container.innerHTML = '<div class="empty-state"><i class="fas fa-code-branch"></i><h3>No Pending Branch Requests</h3><p>All branch requests have been processed.</p></div>'; return; }
            
            // Group branch requests by parent node for tree view
            let html = '';
            branchRequests.forEach(request => {
                const org = adminOrganizations.find(o => o.id === selectedOrgId);
                const orgName = org?.name || selectedOrgId;
                
                // Find existing siblings (other sub-nodes under same parent)
                const existingSiblings = subNodes.filter(node => {
                    // Check if this node is a direct child of the parent
                    const parentPath = request.parentNodePath || `hierarchies/${selectedOrgId}`;
                    return node.path.startsWith(parentPath + '/sub-nodes/') && 
                           node.path.split('/sub-nodes/').length === parentPath.split('/sub-nodes/').length + 1;
                });
                
                html += `
                <div class="branch-tree-container">
                    <div class="branch-tree-header">
                        <div>
                            <div class="branch-tree-title">Branch Request: ${request.proposedName}</div>
                            <div class="branch-tree-requester">Requested by: ${request.requesterEmail}  ${request.createdAt ? new Date(request.createdAt.seconds * 1000).toLocaleDateString() : 'N/A'}</div>
                        </div>
                    </div>
                    <div class="tree-view">
                        <div class="tree-node">
                            <div class="tree-node-card root">
                                <div class="tree-node-name">${request.parentNodeName || orgName}</div>
                                <div class="tree-node-type">${request.parentNodeName ? 'Parent Node' : 'Organization'}</div>
                            </div>
                            <div class="tree-connector"></div>
                            <div class="tree-children">
                                ${existingSiblings.map(sibling => `
                                    <div class="tree-child">
                                        <div class="tree-node-card existing">
                                            <div class="tree-node-name">${sibling.name}</div>
                                            <div class="tree-node-type">${sibling.type || 'department'}</div>
                                        </div>
                                    </div>
                                `).join('')}
                                <div class="tree-child">
                                    <div class="tree-node-card pending-request">
                                        <div class="tree-node-name">${request.proposedName}</div>
                                        <div class="tree-node-type">${request.proposedType || 'department'}</div>
                                        <div class="tree-node-badge">Pending Approval</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="tree-actions">
                        <button class="action-btn approve" onclick="approveBranchRequest('${request.id}')"><i class="fas fa-check"></i> Approve</button>
                        <button class="action-btn merge" onclick="openBranchMergeModal('${request.id}')"><i class="fas fa-code-merge"></i> Merge</button>
                        <button class="action-btn restructure" onclick="openRestructureModal('${request.id}')"><i class="fas fa-project-diagram"></i> Restructure</button>
                        <button class="action-btn reject" onclick="openRejectModal('${request.id}', 'branch', '${request.requesterEmail}')"><i class="fas fa-times"></i> Reject</button>
                    </div>
                </div>`;
            });
            
            container.innerHTML = html;
        }

        function renderSubNodes() {
            const container = document.getElementById('subnodeTree');
            if (subNodes.length === 0) { container.innerHTML = '<div class="empty-state"><i class="fas fa-sitemap"></i><h3>No Sub-Nodes</h3><p>Create sub-nodes to organize your hierarchy.</p></div>'; return; }
            
            container.innerHTML = subNodes.map(node => {
                // For node admins, check if this node is at or below their managed level
                // Node admins can only edit/delete nodes at or below their managed node
                const canModify = !isNodeAdmin || (selectedNodePath && node.path.startsWith(selectedNodePath));
                const isRootManagedNode = isNodeAdmin && node.isManaged; // The node admin's own managed node
                
                // Node admin cannot delete their own managed node (root of their scope)
                const canDelete = canModify && !isRootManagedNode;
                
                return `<div class="subnode-item" style="margin-left:${node.level * 20}px;">
                    <div class="subnode-info">
                        <div class="subnode-name">${node.level > 0 ? ' ' : ''}${node.name}${isRootManagedNode ? ' <span style="color:#8B5CF6;font-size:0.75rem;">(Your Managed Node)</span>' : ''}</div>
                        <div class="subnode-meta">${node.type || 'department'}  ${(node.members || []).length} members  ${(node.adminEmails || []).length > 0 ? 'Admin: ' + node.adminEmails.join(', ') : 'No admin'}</div>
                    </div>
                    <div class="subnode-actions">
                        ${canModify ? `<button class="action-btn assign" onclick="openAssignNodeAdminModal('${node.path}', '${node.name}')">Assign Admin</button>` : ''}
                        ${canModify ? `<button class="action-btn view" onclick="editSubnode('${node.id}', '${node.path}')">Edit</button>` : ''}
                        ${canDelete ? `<button class="action-btn reject" onclick="deleteSubnode('${node.path}', '${node.name}')">Delete</button>` : ''}
                    </div>
                </div>`;
            }).join('');
        }

        async function renderMembers(org) {
            const container = document.getElementById('membersTable');
            let members = [];
            let adminEmails = [];
            let scopeLabel = '';
            
            if (isNodeAdmin && selectedNodePath) {
                // Node admin - show members from their managed node and all children
                scopeLabel = ' (within your managed scope)';
                const memberSet = new Set();
                const adminSet = new Set();
                
                // Collect members from all nodes in scope
                for (const node of subNodes) {
                    if (node.members) {
                        node.members.forEach(m => memberSet.add(m));
                    }
                    if (node.adminEmails) {
                        node.adminEmails.forEach(a => adminSet.add(a));
                    }
                }
                
                members = Array.from(memberSet);
                adminEmails = Array.from(adminSet);
            } else if (org) {
                // Organization admin - show all org members
                members = org.members || [];
                adminEmails = org.adminEmails || [];
            }
            
            if (members.length === 0) { 
                container.innerHTML = `<div class="empty-state"><i class="fas fa-users"></i><h3>No Members${scopeLabel}</h3><p>No members have joined yet.</p></div>`; 
                return; 
            }
            
            // For node admins, disable org-level admin management
            const canManageOrgAdmins = !isNodeAdmin;
            
            container.innerHTML = `<table><thead><tr><th>Email</th><th>Role</th><th>Actions</th></tr></thead><tbody>${members.map(email => {
                const isOrgAdmin = org?.adminEmails?.includes(email);
                const isNodeAdminUser = adminEmails.includes(email) && !isOrgAdmin;
                const roleLabel = isOrgAdmin ? 'Org Admin' : (isNodeAdminUser ? 'Node Admin' : 'Member');
                const roleClass = isOrgAdmin ? 'active' : (isNodeAdminUser ? 'join' : 'pending');
                
                return `<tr>
                    <td><strong>${email}</strong></td>
                    <td><span class="status-badge ${roleClass}">${roleLabel}</span></td>
                    <td>
                        ${canManageOrgAdmins && !isOrgAdmin ? `<button class="action-btn approve" onclick="makeAdmin('${email}')">Make Org Admin</button>` : ''}
                        ${canManageOrgAdmins && isOrgAdmin ? `<button class="action-btn reject" onclick="removeAdmin('${email}')">Remove Org Admin</button>` : ''}
                        ${canManageOrgAdmins ? `<button class="action-btn reject" onclick="removeMember('${email}')">Remove</button>` : ''}
                        ${!canManageOrgAdmins ? '<span style="color:#6B7280;font-size:0.85rem;">View only</span>' : ''}
                    </td>
                </tr>`;
            }).join('')}</tbody></table>`;
        }

        function renderProblems() {
            const container = document.getElementById('problemsTable');
            if (allProblems.length === 0) { container.innerHTML = '<div class="empty-state"><i class="fas fa-exclamation-triangle"></i><h3>No Problems</h3><p>No problems reported yet.</p></div>'; return; }
            container.innerHTML = `<table><thead><tr><th>Title</th><th>Priority</th><th>Status</th><th>Created By</th><th>Date</th><th>Actions</th></tr></thead><tbody>${allProblems.map(item => `<tr>
                <td><strong>${item.title || 'Untitled'}</strong></td>
                <td><span class="status-badge ${item.priority || 'medium'}">${item.priority || 'medium'}</span></td>
                <td><span class="status-badge ${item.status || 'pending'}">${item.status || 'pending'}</span></td>
                <td>${item.createdBy || 'Unknown'}</td>
                <td>${item.createdAt ? new Date(item.createdAt.seconds * 1000).toLocaleDateString() : 'N/A'}</td>
                <td><button class="action-btn view" onclick="viewProblem('${item.id}')">View</button>${item.status !== 'solved' ? `<button class="action-btn approve" onclick="markSolved('${item.id}')">Solved</button>` : ''}</td>
            </tr>`).join('')}</tbody></table>`;
        }

        function renderAnnouncements() {
            const container = document.getElementById('announcementsTable');
            if (allAnnouncements.length === 0) { container.innerHTML = '<div class="empty-state"><i class="fas fa-bullhorn"></i><h3>No Announcements</h3><p>No announcements posted yet.</p></div>'; return; }
            container.innerHTML = `<table><thead><tr><th>Title</th><th>Created By</th><th>Date</th><th>Actions</th></tr></thead><tbody>${allAnnouncements.map(item => `<tr>
                <td><strong>${item.title || 'Untitled'}</strong></td>
                <td>${item.createdBy || 'Unknown'}</td>
                <td>${item.createdAt ? new Date(item.createdAt.seconds * 1000).toLocaleDateString() : 'N/A'}</td>
                <td><button class="action-btn view" onclick="viewAnnouncement('${item.id}')">View</button><button class="action-btn reject" onclick="deleteAnnouncement('${item.id}')">Delete</button></td>
            </tr>`).join('')}</tbody></table>`;
        }

        // Join/Branch Request Actions
        window.approveJoinRequest = async function(requestId) {
            try {
                const request = joinRequests.find(r => r.id === requestId);
                if (!request) return;
                
                console.log('Approving join request:', request);
                
                // Add user to target node's members in global hierarchy
                const targetRef = doc(db, request.targetNodePath);
                await setDoc(targetRef, { 
                    members: arrayUnion(request.requesterEmail), 
                    updatedAt: serverTimestamp() 
                }, { merge: true });
                
                // First, ensure all PARENT nodes exist and are active in user's hierarchy
                // This activates: IIIT BHOPAL -> 2029 -> CSE (parents of DS)
                await ensureUserHierarchyPath(request.requesterEmail, request.targetNodePath);
                
                // Then update the TARGET node itself to active
                // Convert global path to user path: hierarchies/org/sub-nodes/... -> users/email/hierarchies/org/sub-nodes/...
                const userNodePath = request.targetNodePath.replace('hierarchies/', `users/${request.requesterEmail}/hierarchies/`);
                console.log('Updating target user node at:', userNodePath);
                
                const userNodeRef = doc(db, userNodePath);
                await setDoc(userNodeRef, { 
                    name: request.targetNodeName,
                    status: 'active',
                    approvedAt: serverTimestamp(),
                    approvedBy: currentUser.email
                }, { merge: true });
                
                // Remove from admin's notifications (use assignedAdminEmail from request)
                try {
                    const adminEmail = request.assignedAdminEmail || currentUser.email;
                    console.log('Removing from notifications for admin:', adminEmail, 'requestId:', requestId);
                    const adminNotifRef = doc(db, 'users', adminEmail, 'notifications', 'pending');
                    await setDoc(adminNotifRef, {
                        joinRequests: arrayRemove(requestId),
                        updatedAt: serverTimestamp()
                    }, { merge: true });
                    console.log('Removed from admin notifications');
                    
                    // Also remove from current user's notifications if different
                    if (adminEmail !== currentUser.email) {
                        const currentUserNotifRef = doc(db, 'users', currentUser.email, 'notifications', 'pending');
                        await setDoc(currentUserNotifRef, {
                            joinRequests: arrayRemove(requestId),
                            updatedAt: serverTimestamp()
                        }, { merge: true });
                        console.log('Removed from current user notifications');
                    }
                } catch (notifError) {
                    console.error('Error removing from notifications:', notifError);
                    // Continue anyway - don't block approval
                }
                
                // Delete the pending approval
                await deleteDoc(doc(db, 'pendingApprovals', requestId));
                
                showToast('Join request approved! User is now a member.', 'success');
                await loadOrganizationData();
            } catch (error) { 
                console.error('Error approving join request:', error);
                showToast('Error: ' + error.message, 'error'); 
            }
        };

        window.approveBranchRequest = async function(requestId) {
            try {
                const request = branchRequests.find(r => r.id === requestId);
                if (!request) return;
                
                console.log('Approving branch request:', request);
                
                // Create the new sub-node ID
                const nodeId = request.proposedName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
                const orgId = request.parentOrgId || selectedOrgId;
                
                console.log('Creating node with ID:', nodeId, 'orgId:', orgId);
                
                // 1. Create in global hierarchy
                const globalNodePath = `${request.parentNodePath}/sub-nodes/${nodeId}`;
                const globalNodeRef = doc(db, globalNodePath);
                await setDoc(globalNodeRef, {
                    name: request.proposedName,
                    type: request.proposedType || 'department',
                    status: 'active',
                    members: [request.requesterEmail],
                    adminEmails: [],
                    createdBy: request.requesterEmail,
                    createdAt: serverTimestamp()
                });
                console.log('Created global node at:', globalNodePath);
                
                // 2. Convert global path to user hierarchy path
                // Global: hierarchies/iiit-bhopal/sub-nodes/2029/sub-nodes/cse
                // User:   users/{email}/hierarchies/iiit-bhopal/sub-nodes/2029/sub-nodes/cse
                const userNodePath = globalNodePath.replace('hierarchies/', `users/${request.requesterEmail}/hierarchies/`);
                console.log('User node path:', userNodePath);
                
                const userNodeRef = doc(db, userNodePath);
                await setDoc(userNodeRef, {
                    name: request.proposedName,
                    type: request.proposedType || 'department',
                    status: 'active',
                    approvedAt: serverTimestamp(),
                    approvedBy: currentUser.email
                }, { merge: true });
                console.log('Updated user node');
                
                // 3. Ensure all parent nodes exist in user's hierarchy
                await ensureUserHierarchyPath(request.requesterEmail, request.parentNodePath);
                console.log('Ensured user hierarchy path exists');
                
                // 4. Delete the old pending node if it was created at wrong location
                // The pending node might have been created at flat level, delete it
                const oldFlatPath = `users/${request.requesterEmail}/hierarchies/${orgId}/sub-nodes/${nodeId}`;
                if (oldFlatPath !== userNodePath) {
                    try {
                        await deleteDoc(doc(db, oldFlatPath));
                        console.log('Deleted old flat node at:', oldFlatPath);
                    } catch (e) {
                        // Node might not exist at old location
                    }
                }
                
                // 5. Remove from admin's notifications (use assignedAdminEmail from request)
                try {
                    const adminEmail = request.assignedAdminEmail || currentUser.email;
                    console.log('Removing from notifications for admin:', adminEmail, 'requestId:', requestId);
                    const adminNotifRef = doc(db, 'users', adminEmail, 'notifications', 'pending');
                    await setDoc(adminNotifRef, {
                        branchRequests: arrayRemove(requestId),
                        updatedAt: serverTimestamp()
                    }, { merge: true });
                    console.log('Removed from admin notifications');
                    
                    // Also remove from current user's notifications if different
                    if (adminEmail !== currentUser.email) {
                        const currentUserNotifRef = doc(db, 'users', currentUser.email, 'notifications', 'pending');
                        await setDoc(currentUserNotifRef, {
                            branchRequests: arrayRemove(requestId),
                            updatedAt: serverTimestamp()
                        }, { merge: true });
                        console.log('Removed from current user notifications');
                    }
                } catch (notifError) {
                    console.error('Error removing from notifications:', notifError);
                    // Continue anyway - don't block approval
                }
                
                // 6. Delete the pending approval
                await deleteDoc(doc(db, 'pendingApprovals', requestId));
                
                showToast('Branch request approved! Sub-node created.', 'success');
                await loadOrganizationData();
            } catch (error) { 
                console.error('Error approving branch request:', error);
                showToast('Error: ' + error.message, 'error'); 
            }
        };
        
        // Helper function to ensure all parent nodes exist in user's hierarchy AND are set to active
        // When a child node is approved, all parent nodes should also become active
        async function ensureUserHierarchyPath(userEmail, globalParentPath) {
            // globalParentPath: hierarchies/iiit-bhopal/sub-nodes/2029
            // We need to ensure: users/{email}/hierarchies/iiit-bhopal and users/{email}/hierarchies/iiit-bhopal/sub-nodes/2029 exist AND are active
            
            const parts = globalParentPath.split('/');
            // parts: ['hierarchies', 'iiit-bhopal', 'sub-nodes', '2029', ...]
            
            if (parts[0] !== 'hierarchies' || parts.length < 2) return;
            
            const orgId = parts[1];
            
            // Ensure root hierarchy exists AND is active
            const userHierarchyRef = doc(db, 'users', userEmail, 'hierarchies', orgId);
            const userHierarchyDoc = await getDoc(userHierarchyRef);
            const orgDoc = await getDoc(doc(db, 'hierarchies', orgId));
            const orgName = orgDoc.exists() ? orgDoc.data().name : orgId;
            const orgType = orgDoc.exists() ? orgDoc.data().type : 'organization';
            
            // Always update to active status (even if exists with pending/draft status)
            await setDoc(userHierarchyRef, {
                name: orgName,
                type: orgType,
                status: 'active',
                updatedAt: serverTimestamp()
            }, { merge: true });
            console.log('Set root hierarchy to active:', `users/${userEmail}/hierarchies/${orgId}`);
            
            // Ensure each sub-node level exists AND is active
            let currentPath = `users/${userEmail}/hierarchies/${orgId}`;
            for (let i = 2; i < parts.length; i += 2) {
                if (parts[i] === 'sub-nodes' && parts[i + 1]) {
                    currentPath += `/sub-nodes/${parts[i + 1]}`;
                    const nodeRef = doc(db, currentPath);
                    
                    // Get name from global hierarchy
                    const globalPath = `hierarchies/${orgId}${currentPath.split(orgId)[1]}`;
                    const globalDoc = await getDoc(doc(db, globalPath));
                    const nodeName = globalDoc.exists() ? globalDoc.data().name : parts[i + 1];
                    const nodeType = globalDoc.exists() ? globalDoc.data().type : 'department';
                    
                    // Always update to active status (even if exists with pending/draft status)
                    await setDoc(nodeRef, {
                        name: nodeName,
                        type: nodeType,
                        status: 'active',
                        updatedAt: serverTimestamp()
                    }, { merge: true });
                    console.log('Set parent node to active:', currentPath);
                }
            }
        }

        window.openRejectModal = function(requestId, type, requesterEmail) {
            currentRejectRequest = { id: requestId, type };
            document.getElementById('rejectRequester').textContent = requesterEmail;
            document.getElementById('rejectReason').value = '';
            document.getElementById('rejectModal').classList.add('show');
        };

        async function confirmReject() {
            if (!currentRejectRequest) return;
            const reason = document.getElementById('rejectReason').value.trim();
            try {
                // Get the request details
                const request = currentRejectRequest.type === 'join' 
                    ? joinRequests.find(r => r.id === currentRejectRequest.id)
                    : branchRequests.find(r => r.id === currentRejectRequest.id);
                
                if (request && currentRejectRequest.type === 'join') {
                    // Update user's personal hierarchy status to rejected
                    const userHierarchyRef = doc(db, 'users', request.requesterEmail, 'hierarchies', request.targetOrgId);
                    const userHierarchyDoc = await getDoc(userHierarchyRef);
                    if (userHierarchyDoc.exists()) {
                        await setDoc(userHierarchyRef, {
                            status: 'rejected',
                            rejectedAt: serverTimestamp(),
                            rejectedBy: currentUser.email,
                            rejectionReason: reason || 'No reason provided'
                        }, { merge: true });
                    }
                }
                
                if (request && currentRejectRequest.type === 'branch') {
                    // Update user's pending sub-node status to rejected
                    const nodeId = request.proposedName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
                    const orgId = request.parentOrgId || selectedOrgId;
                    const userSubNodeRef = doc(db, 'users', request.requesterEmail, 'hierarchies', orgId, 'sub-nodes', nodeId);
                    try {
                        await setDoc(userSubNodeRef, {
                            status: 'rejected',
                            rejectedAt: serverTimestamp(),
                            rejectedBy: currentUser.email,
                            rejectionReason: reason || 'No reason provided'
                        }, { merge: true });
                    } catch (e) {
                        // Node might not exist, that's fine
                    }
                }
                
                // Remove from admin's notifications (use assignedAdminEmail from request)
                const adminEmail = request?.assignedAdminEmail || currentUser.email;
                const adminNotifRef = doc(db, 'users', adminEmail, 'notifications', 'pending');
                const arrayField = currentRejectRequest.type === 'join' ? 'joinRequests' : 'branchRequests';
                await setDoc(adminNotifRef, {
                    [arrayField]: arrayRemove(currentRejectRequest.id),
                    updatedAt: serverTimestamp()
                }, { merge: true });
                
                // Also remove from current user if different
                if (adminEmail !== currentUser.email) {
                    const currentUserNotifRef = doc(db, 'users', currentUser.email, 'notifications', 'pending');
                    await setDoc(currentUserNotifRef, {
                        [arrayField]: arrayRemove(currentRejectRequest.id),
                        updatedAt: serverTimestamp()
                    }, { merge: true });
                }
                
                // Delete the pending approval
                await deleteDoc(doc(db, 'pendingApprovals', currentRejectRequest.id));
                
                closeModal('rejectModal');
                showToast('Request rejected', 'success');
                await loadOrganizationData();
            } catch (error) { 
                console.error('Error rejecting request:', error);
                showToast('Error: ' + error.message, 'error'); 
            }
        }

        // Sub-Node Management
        function openAddSubnodeModal() {
            document.getElementById('subnodeModalTitle').textContent = 'Add Sub-Node';
            document.getElementById('subnodeName').value = '';
            document.getElementById('subnodeType').value = 'department';
            // Populate parent node options
            const parentSelect = document.getElementById('parentNodeSelect');
            const org = adminOrganizations.find(o => o.id === selectedOrgId);
            let options = '';
            
            if (isNodeAdmin && selectedNodePath) {
                // Node admin - only show their managed node and its children as parent options
                const managedNode = subNodes.find(n => n.isManaged);
                if (managedNode) {
                    options = `<option value="${managedNode.path}">${managedNode.name} (Your Managed Node)</option>`;
                }
                // Add child nodes under the managed node
                subNodes.forEach(node => {
                    if (!node.isManaged && node.path.startsWith(selectedNodePath)) {
                        options += `<option value="${node.path}">${''.repeat(node.level)} ${node.name}</option>`;
                    }
                });
            } else {
                // Organization admin - show all nodes including root
                options = `<option value="hierarchies/${selectedOrgId}">${org?.name || 'Organization'} (Root)</option>`;
                subNodes.forEach(node => { options += `<option value="${node.path}">${''.repeat(node.level + 1)} ${node.name}</option>`; });
            }
            
            parentSelect.innerHTML = options;
            document.getElementById('addSubnodeModal').classList.add('show');
        }

        async function saveSubnode() {
            const parentPath = document.getElementById('parentNodeSelect').value;
            const name = document.getElementById('subnodeName').value.trim();
            const type = document.getElementById('subnodeType').value;
            if (!name) { showToast('Please enter a name', 'error'); return; }
            try {
                const nodeId = name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
                const newNodePath = `${parentPath}/sub-nodes/${nodeId}`;
                await setDoc(doc(db, newNodePath), {
                    name, type, status: 'active', members: [], adminEmails: [],
                    createdBy: currentUser.email, createdAt: serverTimestamp()
                });
                closeModal('addSubnodeModal');
                showToast('Sub-node created!', 'success');
                await loadOrganizationData();
            } catch (error) { showToast('Error: ' + error.message, 'error'); }
        }

        window.deleteSubnode = async function(nodePath, nodeName) {
            if (!confirm(`Delete "${nodeName}" and all its children?`)) return;
            try {
                await deleteNodeRecursive(nodePath);
                showToast('Sub-node deleted!', 'success');
                await loadOrganizationData();
            } catch (error) { showToast('Error: ' + error.message, 'error'); }
        };

        async function deleteNodeRecursive(nodePath) {
            const nodeRef = doc(db, nodePath);
            const childrenRef = collection(nodeRef, 'sub-nodes');
            const snapshot = await getDocs(childrenRef);
            for (const docSnap of snapshot.docs) { await deleteNodeRecursive(`${nodePath}/sub-nodes/${docSnap.id}`); }
            await deleteDoc(nodeRef);
        }

        window.openAssignNodeAdminModal = function(nodePath, nodeName) {
            currentAssignNode = { path: nodePath, name: nodeName };
            document.getElementById('assignNodeName').textContent = nodeName;
            document.getElementById('nodeAdminEmail').value = '';
            document.getElementById('assignNodeAdminModal').classList.add('show');
        };

        async function confirmAssignNodeAdmin() {
            if (!currentAssignNode) return;
            const email = document.getElementById('nodeAdminEmail').value.trim();
            if (!email) { showToast('Please enter an email', 'error'); return; }
            try {
                await setDoc(doc(db, currentAssignNode.path), { adminEmails: arrayUnion(email), updatedAt: serverTimestamp() }, { merge: true });
                closeModal('assignNodeAdminModal');
                showToast(`${email} assigned as admin!`, 'success');
                await loadOrganizationData();
            } catch (error) { showToast('Error: ' + error.message, 'error'); }
        }

        // Member Management
        window.makeAdmin = async function(email) {
            if (!confirm(`Make ${email} an admin?`)) return;
            try {
                await setDoc(doc(db, 'hierarchies', selectedOrgId), { adminEmails: arrayUnion(email), updatedAt: serverTimestamp() }, { merge: true });
                showToast(`${email} is now an admin!`, 'success');
                await checkAdminStatus();
            } catch (error) { showToast('Error: ' + error.message, 'error'); }
        };

        window.removeAdmin = async function(email) {
            if (!confirm(`Remove ${email} as admin?`)) return;
            try {
                await setDoc(doc(db, 'hierarchies', selectedOrgId), { adminEmails: arrayRemove(email), updatedAt: serverTimestamp() }, { merge: true });
                showToast(`${email} removed as admin!`, 'success');
                await checkAdminStatus();
            } catch (error) { showToast('Error: ' + error.message, 'error'); }
        };

        window.removeMember = async function(email) {
            if (!confirm(`Remove ${email} from the organization?`)) return;
            try {
                await setDoc(doc(db, 'hierarchies', selectedOrgId), { members: arrayRemove(email), adminEmails: arrayRemove(email), updatedAt: serverTimestamp() }, { merge: true });
                showToast(`${email} removed!`, 'success');
                await checkAdminStatus();
            } catch (error) { showToast('Error: ' + error.message, 'error'); }
        };

        // Problem/Announcement Actions
        window.viewProblem = function(problemId) {
            const problem = allProblems.find(p => p.id === problemId);
            if (!problem) return;
            document.getElementById('modalTitle').textContent = 'Problem Details';
            document.getElementById('modalContent').innerHTML = `
                <div class="detail-row"><span class="detail-label">Title</span><span class="detail-value">${problem.title || 'Untitled'}</span></div>
                <div class="detail-row"><span class="detail-label">Description</span><span class="detail-value">${problem.description || 'No description'}</span></div>
                <div class="detail-row"><span class="detail-label">Priority</span><span class="detail-value"><span class="status-badge ${problem.priority || 'medium'}">${problem.priority || 'medium'}</span></span></div>
                <div class="detail-row"><span class="detail-label">Status</span><span class="detail-value"><span class="status-badge ${problem.status || 'pending'}">${problem.status || 'pending'}</span></span></div>
                <div class="detail-row"><span class="detail-label">Created By</span><span class="detail-value">${problem.createdBy || 'Unknown'}</span></div>`;
            document.getElementById('detailsModal').classList.add('show');
        };

        window.viewAnnouncement = function(announcementId) {
            const announcement = allAnnouncements.find(a => a.id === announcementId);
            if (!announcement) return;
            document.getElementById('modalTitle').textContent = 'Announcement Details';
            document.getElementById('modalContent').innerHTML = `
                <div class="detail-row"><span class="detail-label">Title</span><span class="detail-value">${announcement.title || 'Untitled'}</span></div>
                <div class="detail-row"><span class="detail-label">Content</span><span class="detail-value">${announcement.content || announcement.description || 'No content'}</span></div>
                <div class="detail-row"><span class="detail-label">Created By</span><span class="detail-value">${announcement.createdBy || 'Unknown'}</span></div>`;
            document.getElementById('detailsModal').classList.add('show');
        };

        window.markSolved = async function(problemId) {
            try {
                await setDoc(doc(db, 'problems', problemId), { status: 'solved', solvedAt: serverTimestamp(), solvedBy: currentUser.email }, { merge: true });
                showToast('Problem marked as solved!', 'success');
                await loadOrganizationData();
            } catch (error) { showToast('Error: ' + error.message, 'error'); }
        };

        window.deleteAnnouncement = async function(announcementId) {
            if (!confirm('Delete this announcement?')) return;
            try {
                await deleteDoc(doc(db, 'announcements', announcementId));
                showToast('Announcement deleted!', 'success');
                await loadOrganizationData();
            } catch (error) { showToast('Error: ' + error.message, 'error'); }
        };

        window.closeModal = function(modalId) { document.getElementById(modalId).classList.remove('show'); };

        // Branch Merge Functions
        let currentBranchMergeRequest = null;
        
        window.openBranchMergeModal = function(requestId) {
            const request = branchRequests.find(r => r.id === requestId);
            if (!request) return;
            
            currentBranchMergeRequest = request;
            document.getElementById('mergeBranchName').textContent = request.proposedName;
            document.getElementById('mergeBranchRequester').textContent = request.requesterEmail;
            
            // Populate target sub-nodes dropdown (existing sub-nodes under same parent)
            const targetSelect = document.getElementById('mergeBranchTarget');
            const parentPath = request.parentNodePath || `hierarchies/${selectedOrgId}`;
            
            // Get all sub-nodes that could be merge targets
            let options = '<option value="">-- Select a sub-node --</option>';
            subNodes.forEach(node => {
                // Include nodes under the same parent
                if (node.path.startsWith(parentPath + '/sub-nodes/')) {
                    options += `<option value="${node.path}" data-name="${node.name}">${node.name} (${node.type || 'department'})</option>`;
                }
            });
            
            // If no siblings, show all sub-nodes
            if (subNodes.length > 0 && options === '<option value="">-- Select a sub-node --</option>') {
                subNodes.forEach(node => {
                    options += `<option value="${node.path}" data-name="${node.name}">${node.name} (${node.type || 'department'})</option>`;
                });
            }
            
            targetSelect.innerHTML = options;
            document.getElementById('mergeBranchNameOption').value = 'alias';
            document.getElementById('branchMergeModal').classList.add('show');
        };
        
        async function confirmBranchMerge() {
            if (!currentBranchMergeRequest) return;
            
            const targetPath = document.getElementById('mergeBranchTarget').value;
            const nameOption = document.getElementById('mergeBranchNameOption').value;
            
            if (!targetPath) {
                showToast('Please select a target sub-node', 'error');
                return;
            }
            
            try {
                const request = currentBranchMergeRequest;
                const targetSelect = document.getElementById('mergeBranchTarget');
                const targetName = targetSelect.options[targetSelect.selectedIndex].dataset.name;
                
                // 1. If alias option, add the proposed name to target's nameAliases
                if (nameOption === 'alias') {
                    await setDoc(doc(db, targetPath), {
                        nameAliases: arrayUnion(request.proposedName),
                        updatedAt: serverTimestamp()
                    }, { merge: true });
                }
                
                // 2. Add user to target node's members
                await setDoc(doc(db, targetPath), {
                    members: arrayUnion(request.requesterEmail),
                    updatedAt: serverTimestamp()
                }, { merge: true });
                
                // 3. Create/update user's hierarchy to point to the correct node
                // Convert target global path to user path
                const userTargetPath = targetPath.replace('hierarchies/', `users/${request.requesterEmail}/hierarchies/`);
                const orgId = request.parentOrgId || selectedOrgId;
                
                // Update user's hierarchy with the correct sub-node at the correct nested path
                const userSubNodeRef = doc(db, userTargetPath);
                await setDoc(userSubNodeRef, {
                    name: targetName,
                    type: request.proposedType || 'department',
                    status: 'active',
                    mergedFrom: request.proposedName,
                    mergedAt: serverTimestamp(),
                    approvedBy: currentUser.email
                }, { merge: true });
                
                // 4. Ensure all parent nodes exist in user's hierarchy
                await ensureUserHierarchyPath(request.requesterEmail, request.parentNodePath);
                
                // 5. Delete the pending sub-node in user's hierarchy if it exists (the wrong one)
                const wrongNodeId = request.proposedName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
                
                // Delete from the correct parent path
                const userParentPath = request.parentNodePath.replace('hierarchies/', `users/${request.requesterEmail}/hierarchies/`);
                const wrongNodePath = `${userParentPath}/sub-nodes/${wrongNodeId}`;
                if (wrongNodePath !== userTargetPath) {
                    try {
                        await deleteDoc(doc(db, wrongNodePath));
                        console.log('Deleted wrong node at:', wrongNodePath);
                    } catch (e) {
                        // Node might not exist
                    }
                }
                
                // Also try to delete from flat location
                const flatWrongPath = `users/${request.requesterEmail}/hierarchies/${orgId}/sub-nodes/${wrongNodeId}`;
                if (flatWrongPath !== wrongNodePath && flatWrongPath !== userTargetPath) {
                    try {
                        await deleteDoc(doc(db, flatWrongPath));
                        console.log('Deleted flat wrong node at:', flatWrongPath);
                    } catch (e) {
                        // Node might not exist
                    }
                }
                
                // 6. Remove from admin's notifications
                const adminEmail = request.assignedAdminEmail || currentUser.email;
                const adminNotifRef = doc(db, 'users', adminEmail, 'notifications', 'pending');
                await setDoc(adminNotifRef, {
                    branchRequests: arrayRemove(request.id),
                    updatedAt: serverTimestamp()
                }, { merge: true });
                
                // Also remove from current user if different
                if (adminEmail !== currentUser.email) {
                    const currentUserNotifRef = doc(db, 'users', currentUser.email, 'notifications', 'pending');
                    await setDoc(currentUserNotifRef, {
                        branchRequests: arrayRemove(request.id),
                        updatedAt: serverTimestamp()
                    }, { merge: true });
                }
                
                // 7. Delete the pending approval
                await deleteDoc(doc(db, 'pendingApprovals', request.id));
                
                closeModal('branchMergeModal');
                showToast(`Branch merged into "${targetName}"!`, 'success');
                await loadOrganizationData();
            } catch (error) {
                console.error('Error merging branch:', error);
                showToast('Error: ' + error.message, 'error');
            }
        }
        
        // Event listener for branch merge confirm button
        document.getElementById('confirmBranchMergeBtn').addEventListener('click', confirmBranchMerge);

        // Restructure Functions
        let currentRestructureRequest = null;
        
        window.openRestructureModal = function(requestId) {
            const request = branchRequests.find(r => r.id === requestId);
            if (!request) return;
            
            currentRestructureRequest = request;
            document.getElementById('restructureOriginalName').textContent = request.proposedName;
            document.getElementById('restructureRequester').textContent = request.requesterEmail;
            document.getElementById('restructureMiddleName').value = '';
            document.getElementById('restructureMiddleType').value = 'department';
            document.getElementById('restructurePreview').style.display = 'none';
            
            document.getElementById('restructureModal').classList.add('show');
            
            // Add input listener for live preview
            document.getElementById('restructureMiddleName').addEventListener('input', updateRestructurePreview);
        };
        
        function updateRestructurePreview() {
            const middleName = document.getElementById('restructureMiddleName').value.trim();
            const previewDiv = document.getElementById('restructurePreview');
            const previewPath = document.getElementById('restructurePreviewPath');
            
            if (!middleName || !currentRestructureRequest) {
                previewDiv.style.display = 'none';
                return;
            }
            
            const org = adminOrganizations.find(o => o.id === selectedOrgId);
            const parentName = currentRestructureRequest.parentNodeName || org?.name || 'Organization';
            const requestedName = currentRestructureRequest.proposedName;
            
            previewPath.innerHTML = `
                <span class="preview-node">${parentName}</span>
                <span class="preview-arrow"></span>
                <span class="preview-node new">${middleName} (NEW)</span>
                <span class="preview-arrow"></span>
                <span class="preview-node moved">${requestedName}</span>
            `;
            previewDiv.style.display = 'block';
        }
        
        async function confirmRestructure() {
            if (!currentRestructureRequest) return;
            
            const middleName = document.getElementById('restructureMiddleName').value.trim();
            const middleType = document.getElementById('restructureMiddleType').value;
            
            if (!middleName) {
                showToast('Please enter the intermediate node name', 'error');
                return;
            }
            
            try {
                const request = currentRestructureRequest;
                const orgId = request.parentOrgId || selectedOrgId;
                
                // Create IDs
                const middleNodeId = middleName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
                const finalNodeId = request.proposedName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
                
                // 1. Create the intermediate node in global hierarchy
                const middleNodePath = `${request.parentNodePath}/sub-nodes/${middleNodeId}`;
                const middleNodeRef = doc(db, middleNodePath);
                await setDoc(middleNodeRef, {
                    name: middleName,
                    type: middleType,
                    status: 'active',
                    members: [],
                    adminEmails: [],
                    nameAliases: [middleName],
                    createdBy: currentUser.email,
                    createdAt: serverTimestamp()
                });
                
                // 2. Create the final node under the intermediate node in global hierarchy
                const finalNodePath = `${middleNodePath}/sub-nodes/${finalNodeId}`;
                const finalNodeRef = doc(db, finalNodePath);
                await setDoc(finalNodeRef, {
                    name: request.proposedName,
                    type: request.proposedType || 'department',
                    status: 'active',
                    members: [request.requesterEmail],
                    adminEmails: [],
                    nameAliases: [request.proposedName],
                    createdBy: request.requesterEmail,
                    createdAt: serverTimestamp()
                });
                
                // 3. Convert global paths to user hierarchy paths
                const userMiddleNodePath = middleNodePath.replace('hierarchies/', `users/${request.requesterEmail}/hierarchies/`);
                const userFinalNodePath = finalNodePath.replace('hierarchies/', `users/${request.requesterEmail}/hierarchies/`);
                
                // Create intermediate node in user's hierarchy
                const userMiddleNodeRef = doc(db, userMiddleNodePath);
                await setDoc(userMiddleNodeRef, {
                    name: middleName,
                    type: middleType,
                    status: 'active',
                    createdAt: serverTimestamp()
                });
                
                // 4. Create final node under intermediate in user's hierarchy
                const userFinalNodeRef = doc(db, userFinalNodePath);
                await setDoc(userFinalNodeRef, {
                    name: request.proposedName,
                    type: request.proposedType || 'department',
                    status: 'active',
                    restructuredAt: serverTimestamp(),
                    approvedBy: currentUser.email
                });
                
                // 5. Delete the old pending node in user's hierarchy
                // It might be at the wrong flat location or at the parent level
                const oldUserParentPath = request.parentNodePath.replace('hierarchies/', `users/${request.requesterEmail}/hierarchies/`);
                const oldPendingNodePath = `${oldUserParentPath}/sub-nodes/${finalNodeId}`;
                if (oldPendingNodePath !== userFinalNodePath) {
                    try {
                        await deleteDoc(doc(db, oldPendingNodePath));
                        console.log('Deleted old pending node at:', oldPendingNodePath);
                    } catch (e) {
                        // Node might not exist at old location
                    }
                }
                
                // Also try to delete from flat location
                const flatOldPath = `users/${request.requesterEmail}/hierarchies/${orgId}/sub-nodes/${finalNodeId}`;
                if (flatOldPath !== userFinalNodePath && flatOldPath !== oldPendingNodePath) {
                    try {
                        await deleteDoc(doc(db, flatOldPath));
                        console.log('Deleted old flat node at:', flatOldPath);
                    } catch (e) {
                        // Node might not exist
                    }
                }
                
                // 6. Ensure all parent nodes exist in user's hierarchy
                await ensureUserHierarchyPath(request.requesterEmail, request.parentNodePath);
                
                // 7. Remove from admin's notifications
                const adminEmail = request.assignedAdminEmail || currentUser.email;
                const adminNotifRef = doc(db, 'users', adminEmail, 'notifications', 'pending');
                await setDoc(adminNotifRef, {
                    branchRequests: arrayRemove(request.id),
                    updatedAt: serverTimestamp()
                }, { merge: true });
                
                // 8. Delete the pending approval
                await deleteDoc(doc(db, 'pendingApprovals', request.id));
                
                closeModal('restructureModal');
                showToast(`Restructured: ${request.parentNodeName || 'Org'}  ${middleName}  ${request.proposedName}`, 'success');
                await loadOrganizationData();
            } catch (error) {
                console.error('Error restructuring branch:', error);
                showToast('Error: ' + error.message, 'error');
            }
        }
        
        // Event listener for restructure confirm button
        document.getElementById('confirmRestructureBtn').addEventListener('click', confirmRestructure);

        // ========== GOVERNANCE & APPROVAL CENTER FUNCTIONALITY ==========
        
        // Real data arrays for governance features (loaded from Firebase)
        let pendingProblemApprovals = [];
        let pendingAnnouncementApprovals = [];
        let escalatedItems = [];
        let archivedItems = [];
        let currentGovAction = null;
        
        // Load real governance data from Firebase
        async function initGovernanceData() {
            console.log('Initializing governance data...');
            try {
                // Load pending problem approvals from Firebase
                await loadPendingProblemApprovals();
                console.log('Loaded problem approvals');
                
                // Note: Announcements no longer need approval since only admins can post
                // pendingAnnouncementApprovals stays empty
                
                // Load escalated items
                await loadEscalatedItems();
                console.log('Loaded escalated items');
                
                // Load archived items
                await loadArchivedItems();
                console.log('Loaded archived items');
                
            } catch (error) {
                console.error('Error initializing governance data:', error);
            }
            
            // Always render panels and update metrics, even if loading failed
            updateGovernanceMetrics();
            renderGovernancePanels();
            console.log('Governance panels rendered');
        }
        
        // Load pending problem approvals from Firebase
        async function loadPendingProblemApprovals() {
            try {
                const pendingRef = collection(db, 'pendingProblemApprovals');
                const snapshot = await getDocs(pendingRef);
                
                pendingProblemApprovals = [];
                
                for (const docSnap of snapshot.docs) {
                    const data = docSnap.data();
                    
                    // Check if this problem is assigned to current admin's organization
                    const assignedAdmins = data.assignedAdminEmails || [];
                    const hierarchyPaths = data.hierarchyPaths || [];
                    
                    // Check if current user is an assigned admin or if problem is in their org
                    let isRelevant = assignedAdmins.includes(currentUser?.email);
                    
                    if (!isRelevant && selectedOrgId) {
                        // Check if any hierarchy path matches the selected org
                        isRelevant = hierarchyPaths.some(path => path.includes(selectedOrgId));
                    }
                    
                    if (isRelevant || assignedAdmins.length === 0) {
                        // Extract hierarchy path names from hierarchyPaths
                        let pathNames = [];
                        if (hierarchyPaths.length > 0) {
                            // Parse the path to get node names
                            const firstPath = hierarchyPaths[0];
                            const pathParts = firstPath.split('/');
                            // Get the org name and sub-node names
                            for (let i = 0; i < pathParts.length; i++) {
                                if (pathParts[i] === 'hierarchies' || pathParts[i] === 'sub-nodes') continue;
                                pathNames.push(pathParts[i]);
                            }
                        }
                        
                        pendingProblemApprovals.push({
                            id: docSnap.id,
                            type: 'problem',
                            title: data.title || 'Untitled Problem',
                            description: data.description || '',
                            submittedBy: data.createdBy || 'Unknown',
                            submittedByOrg: data.category || 'General',
                            hierarchyPath: pathNames.length > 0 ? pathNames : ['Organization'],
                            priority: data.priority || 'medium',
                            category: data.category || 'general',
                            createdAt: data.createdAt?.toDate ? data.createdAt.toDate() : new Date(data.createdAt),
                            status: data.status || 'pending',
                            assignedAdminEmails: assignedAdmins,
                            hierarchyPaths: hierarchyPaths
                        });
                    }
                }
                
                console.log('Loaded pending problem approvals:', pendingProblemApprovals.length);
            } catch (error) {
                console.error('Error loading pending problem approvals:', error);
                pendingProblemApprovals = [];
            }
        }
        
        // Load pending announcement approvals from Firebase
        async function loadPendingAnnouncementApprovals() {
            try {
                const pendingRef = collection(db, 'pendingAnnouncementApprovals');
                const snapshot = await getDocs(pendingRef);
                
                pendingAnnouncementApprovals = [];
                
                for (const docSnap of snapshot.docs) {
                    const data = docSnap.data();
                    
                    // Check if this announcement is relevant to current admin
                    const assignedAdmins = data.assignedAdminEmails || [];
                    let isRelevant = assignedAdmins.includes(currentUser?.email) || assignedAdmins.length === 0;
                    
                    if (isRelevant) {
                        pendingAnnouncementApprovals.push({
                            id: docSnap.id,
                            type: 'announcement',
                            title: data.title || 'Untitled Announcement',
                            content: data.content || data.description || '',
                            submittedBy: data.createdBy || 'Unknown',
                            submittedByOrg: data.category || 'General',
                            hierarchyPath: data.hierarchyPath || ['Organization'],
                            scope: data.scope || 'org',
                            deadline: data.deadline?.toDate ? data.deadline.toDate() : (data.deadline ? new Date(data.deadline) : null),
                            isUrgent: data.isUrgent || false,
                            isVerified: data.isVerified || false,
                            createdAt: data.createdAt?.toDate ? data.createdAt.toDate() : new Date(data.createdAt),
                            status: data.status || 'pending'
                        });
                    }
                }
                
                console.log('Loaded pending announcement approvals:', pendingAnnouncementApprovals.length);
            } catch (error) {
                console.error('Error loading pending announcement approvals:', error);
                pendingAnnouncementApprovals = [];
            }
        }
        
        // Load escalated items from Firebase
        async function loadEscalatedItems() {
            try {
                const escalatedRef = collection(db, 'escalatedProblems');
                const snapshot = await getDocs(escalatedRef);
                
                escalatedItems = [];
                
                for (const docSnap of snapshot.docs) {
                    const data = docSnap.data();
                    
                    escalatedItems.push({
                        id: docSnap.id,
                        type: 'problem',
                        title: data.title || 'Untitled',
                        description: data.description || '',
                        submittedBy: data.createdBy || 'Unknown',
                        previousLevel: data.previousLevel || 'Unknown',
                        currentLevel: data.currentLevel || 'Admin',
                        escalationReason: data.escalationReason || 'Escalated by admin',
                        escalationPath: data.escalationPath || [],
                        priority: data.priority || 'high',
                        createdAt: data.createdAt?.toDate ? data.createdAt.toDate() : new Date(),
                        escalatedAt: data.escalatedAt?.toDate ? data.escalatedAt.toDate() : new Date()
                    });
                }
                
                console.log('Loaded escalated items:', escalatedItems.length);
            } catch (error) {
                console.error('Error loading escalated items:', error);
                escalatedItems = [];
            }
        }
        
        // Load archived items from Firebase
        async function loadArchivedItems() {
            try {
                const archivedRef = collection(db, 'archivedProblems');
                const snapshot = await getDocs(archivedRef);
                
                archivedItems = [];
                
                for (const docSnap of snapshot.docs) {
                    const data = docSnap.data();
                    
                    archivedItems.push({
                        id: docSnap.id,
                        type: data.type || 'problem',
                        title: data.title || 'Untitled',
                        archiveReason: data.archiveReason || 'Archived',
                        archivedBy: data.archivedBy || 'admin',
                        archivedAt: data.archivedAt?.toDate ? data.archivedAt.toDate() : new Date()
                    });
                }
                
                console.log('Loaded archived items:', archivedItems.length);
            } catch (error) {
                console.error('Error loading archived items:', error);
                archivedItems = [];
            }
        }
        
        // Update governance metrics
        function updateGovernanceMetrics() {
            const totalPending = pendingProblemApprovals.length;
            document.getElementById('pendingApprovalsCount').textContent = totalPending;
            document.getElementById('pendingTabBadge').textContent = totalPending;
            document.getElementById('escalationTabBadge').textContent = escalatedItems.length;
            document.getElementById('escalatedCount').textContent = escalatedItems.length;
            document.getElementById('archivedCount').textContent = archivedItems.length;
        }
        
        // Setup governance tabs
        function setupGovernanceTabs() {
            // Main governance tabs
            document.querySelectorAll('.gov-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabId = tab.dataset.tab;
                    document.querySelectorAll('.gov-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    document.querySelectorAll('.governance-panel').forEach(p => p.classList.remove('active'));
                    document.getElementById(`${tabId}-panel`).classList.add('active');
                });
            });
            
            // Escalation sub-tabs
            document.querySelectorAll('.esc-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabId = tab.dataset.esctab;
                    document.querySelectorAll('.esc-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    document.querySelectorAll('.escalation-content').forEach(c => c.classList.remove('active'));
                    document.getElementById(`${tabId}-content`).classList.add('active');
                });
            });
            
            // Filter chips
            document.querySelectorAll('.filter-chip').forEach(chip => {
                chip.addEventListener('click', () => {
                    document.querySelectorAll('.filter-chip').forEach(c => c.classList.remove('active'));
                    chip.classList.add('active');
                    renderPendingApprovals(chip.dataset.filter);
                });
            });
        }
        
        // Render all governance panels
        function renderGovernancePanels() {
            renderPendingApprovals('all');
            renderEscalations();
            renderArchive();
        }
        
        // Render pending approvals
        function renderPendingApprovals(filter = 'all') {
            const container = document.getElementById('pendingApprovalsList');
            let items = [...pendingProblemApprovals];
            
            if (filter === 'problem') items = pendingProblemApprovals;
            else if (filter === 'escalation') items = escalatedItems.map(e => ({...e, type: 'escalation'}));
            
            if (items.length === 0) {
                container.innerHTML = `<div class="governance-empty"><i class="fas fa-clipboard-check"></i><h3>No Pending Approvals</h3><p>All items have been reviewed.</p></div>`;
                return;
            }
            
            container.innerHTML = items.map(item => {
                const age = getAge(item.createdAt);
                const isUrgent = age.days >= 3;
                
                return `
                <div class="approval-item" data-id="${item.id}">
                    <div class="approval-header" onclick="toggleApprovalExpand('${item.id}')">
                        <span class="approval-type-badge ${item.type}">${item.type}</span>
                        <div class="approval-info">
                            <div class="approval-title">${item.title}</div>
                            <div class="approval-meta">
                                <span><i class="fas fa-user"></i> ${item.submittedBy}</span>
                                <span><i class="fas fa-building"></i> ${item.submittedByOrg || 'Unknown'}</span>
                                ${item.priority ? `<span><span class="priority-indicator ${item.priority}"></span> ${item.priority}</span>` : ''}
                            </div>
                        </div>
                        <span class="approval-age ${isUrgent ? 'urgent' : ''}">${age.text}</span>
                        <button class="approval-expand-btn"><i class="fas fa-chevron-down"></i></button>
                    </div>
                    <div class="approval-details">
                        <div class="approval-path">
                            <i class="fas fa-sitemap"></i>
                            ${(item.hierarchyPath || []).map((node, i) => `
                                <span class="path-node">${node}</span>
                                ${i < item.hierarchyPath.length - 1 ? '<span class="path-arrow"></span>' : ''}
                            `).join('')}
                        </div>
                        <div class="approval-description">${item.description || item.content || 'No description provided.'}</div>
                        <div class="approval-actions">
                            <button class="action-btn approve" onclick="govApprove('${item.id}', '${item.type}')"><i class="fas fa-check"></i> Approve</button>
                            <button class="action-btn reject" onclick="openGovRejectModal('${item.id}', '${item.title}', '${item.type}')"><i class="fas fa-times"></i> Reject</button>
                            <button class="action-btn escalate" onclick="openGovEscalateModal('${item.id}', '${item.title}', '${item.type}')"><i class="fas fa-level-up-alt"></i> Escalate</button>
                            <button class="action-btn archive" onclick="openGovArchiveModal('${item.id}', '${item.title}', '${item.type}')"><i class="fas fa-archive"></i> Archive</button>
                        </div>
                    </div>
                </div>`;
            }).join('');
        }
        
        // Render escalations
        function renderEscalations() {
            const container = document.getElementById('escalationList');
            
            if (escalatedItems.length === 0) {
                container.innerHTML = `<div class="governance-empty"><i class="fas fa-level-up-alt"></i><h3>No Escalated Items</h3><p>No problems have been escalated to your level.</p></div>`;
                return;
            }
            
            container.innerHTML = escalatedItems.map(item => `
                <div class="escalation-item">
                    <div class="escalation-header">
                        <div class="escalation-title">${item.title}</div>
                        <span class="escalation-reason"><i class="fas fa-exclamation-circle"></i> ${item.escalationReason}</span>
                    </div>
                    <div class="escalation-path-trail">
                        <i class="fas fa-route"></i>
                        ${(item.escalationPath || []).map((node, i) => `
                            <span class="trail-node ${i === item.escalationPath.length - 1 ? 'current' : ''}">${node}</span>
                            ${i < item.escalationPath.length - 1 ? '<span class="path-arrow"></span>' : ''}
                        `).join('')}
                    </div>
                    <p style="color:#6B7280;font-size:0.9rem;margin-bottom:1rem;">${item.description}</p>
                    <div class="escalation-actions">
                        <button class="action-btn approve" onclick="govApproveEscalation('${item.id}')"><i class="fas fa-check"></i> Approve & Resolve</button>
                        <button class="action-btn send-back" onclick="govSendBack('${item.id}')"><i class="fas fa-undo"></i> Send Back</button>
                        <button class="action-btn force-escalate" onclick="govForceEscalate('${item.id}')"><i class="fas fa-arrow-up"></i> Force Escalate</button>
                        <button class="action-btn archive" onclick="openGovArchiveModal('${item.id}', '${item.title}', 'escalation')"><i class="fas fa-archive"></i> Archive</button>
                    </div>
                </div>
            `).join('');
        }
        
        // Render archive
        function renderArchive() {
            const container = document.getElementById('archiveList');
            
            if (archivedItems.length === 0) {
                container.innerHTML = `<div class="governance-empty"><i class="fas fa-archive"></i><h3>No Archived Items</h3><p>Archived problems and announcements will appear here.</p></div>`;
                return;
            }
            
            container.innerHTML = archivedItems.map(item => `
                <div class="archive-item">
                    <div class="archive-header">
                        <div class="archive-title">${item.title}</div>
                        <span class="approval-type-badge ${item.type}">${item.type}</span>
                    </div>
                    <div class="archive-reason"><i class="fas fa-info-circle"></i> ${item.archiveReason}</div>
                    <div class="archive-actions">
                        <button class="action-btn restore" onclick="govRestore('${item.id}')"><i class="fas fa-undo"></i> Restore</button>
                        <button class="action-btn view" onclick="viewArchivedItem('${item.id}')"><i class="fas fa-eye"></i> View</button>
                    </div>
                </div>
            `).join('');
        }
        
        // Helper: Get age text
        function getAge(date) {
            const now = new Date();
            const diff = now - new Date(date);
            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const hours = Math.floor(diff / (1000 * 60 * 60));
            
            if (days > 0) return { days, text: `${days}d ago` };
            if (hours > 0) return { days: 0, text: `${hours}h ago` };
            return { days: 0, text: 'Just now' };
        }
        
        // Toggle approval item expand
        window.toggleApprovalExpand = function(id) {
            const item = document.querySelector(`.approval-item[data-id="${id}"]`);
            if (item) item.classList.toggle('expanded');
        };
        
        // Governance Actions
        window.govApprove = function(id, type) {
            // Add ripple effect
            const item = document.querySelector(`.approval-item[data-id="${id}"]`);
            if (item) item.classList.add('approval-success-ripple');
            
            setTimeout(async () => {
                try {
                    if (type === 'problem') {
                        // Find the problem data
                        const problem = pendingProblemApprovals.find(p => p.id === id);
                        console.log('Approving problem:', id, problem);
                        
                        // Move to main problems collection (not approvedProblems)
                        if (problem) {
                            const problemRef = doc(db, 'problems', id);
                            // Create a clean object without circular references
                            // Include vote fields for the upvote/downvote system
                            const problemData = {
                                title: problem.title || '',
                                description: problem.description || '',
                                category: problem.category || 'general',
                                // Vote-based priority system
                                upvotes: problem.upvotes || 0,
                                downvotes: problem.downvotes || 0,
                                voters: problem.voters || [],
                                hierarchyLevel: problem.hierarchyLevel || 0,
                                submittedBy: problem.submittedBy || problem.createdBy || '',
                                createdBy: problem.createdBy || problem.submittedBy || '',
                                hierarchyPath: problem.hierarchyPath || [],
                                hierarchyPaths: problem.hierarchyPaths || [],
                                targetNodes: problem.targetNodes || [],
                                assignedAdminEmails: problem.assignedAdminEmails || [],
                                status: 'open',
                                approvedBy: currentUser?.email || '',
                                approvedAt: serverTimestamp(),
                                createdAt: problem.createdAt instanceof Date ? problem.createdAt : serverTimestamp()
                            };
                            console.log('Saving to problems collection:', problemData);
                            await setDoc(problemRef, problemData);
                            console.log('Saved to problems collection');
                            
                            // Add problem ID to hierarchy nodes' problemIds array
                            if (problem.hierarchyPaths && problem.hierarchyPaths.length > 0) {
                                for (const path of problem.hierarchyPaths) {
                                    try {
                                        const nodeRef = doc(db, path);
                                        await setDoc(nodeRef, {
                                            problemIds: arrayUnion(id),
                                            updatedAt: serverTimestamp()
                                        }, { merge: true });
                                        console.log('Added problem ID to node:', path);
                                    } catch (nodeError) {
                                        console.error('Error updating node:', path, nodeError);
                                    }
                                }
                            }
                        }
                        
                        // Delete from pending
                        console.log('Deleting from pendingProblemApprovals:', id);
                        try {
                            await deleteDoc(doc(db, 'pendingProblemApprovals', id));
                            console.log('Deleted from pendingProblemApprovals');
                        } catch (deleteError) {
                            console.error('Error deleting from pending:', deleteError);
                        }
                        pendingProblemApprovals = pendingProblemApprovals.filter(p => p.id !== id);
                    } else if (type === 'announcement') {
                        // Find the announcement data
                        const announcement = pendingAnnouncementApprovals.find(a => a.id === id);
                        
                        // Move to announcements collection
                        if (announcement) {
                            const announcementRef = doc(db, 'announcements', id);
                            const announcementData = {
                                title: announcement.title || '',
                                content: announcement.content || '',
                                submittedBy: announcement.submittedBy || '',
                                createdBy: announcement.createdBy || announcement.submittedBy || '',
                                scope: announcement.scope || 'org',
                                isUrgent: announcement.isUrgent || false,
                                isVerified: true,
                                status: 'published',
                                approvedBy: currentUser?.email || '',
                                approvedAt: serverTimestamp()
                            };
                            await setDoc(announcementRef, announcementData);
                        }
                        
                        // Delete from pending
                        try {
                            await deleteDoc(doc(db, 'pendingAnnouncementApprovals', id));
                        } catch (deleteError) {
                            console.error('Error deleting announcement from pending:', deleteError);
                        }
                        pendingAnnouncementApprovals = pendingAnnouncementApprovals.filter(a => a.id !== id);
                    }
                    updateGovernanceMetrics();
                    renderGovernancePanels();
                    showToast('Item approved successfully!', 'success');
                } catch (error) {
                    console.error('Error approving item:', error);
                    showToast('Error approving item: ' + error.message, 'error');
                }
            }, 300);
        };
        
        window.govApproveAnnouncement = async function(id) {
            const ann = pendingAnnouncementApprovals.find(a => a.id === id);
            if (ann) {
                try {
                    // Move to approved announcements
                    const approvedRef = doc(db, 'approvedAnnouncements', id);
                    await setDoc(approvedRef, {
                        ...ann,
                        isVerified: true,
                        status: 'approved',
                        approvedBy: currentUser?.email,
                        approvedAt: serverTimestamp()
                    });
                    
                    // Delete from pending
                    await deleteDoc(doc(db, 'pendingAnnouncementApprovals', id));
                    pendingAnnouncementApprovals = pendingAnnouncementApprovals.filter(a => a.id !== id);
                    
                    updateGovernanceMetrics();
                    renderGovernancePanels();
                    showToast('Announcement approved and published!', 'success');
                } catch (error) {
                    console.error('Error approving announcement:', error);
                    showToast('Error: ' + error.message, 'error');
                }
            }
        };
        
        window.govApproveEscalation = async function(id) {
            try {
                const item = escalatedItems.find(e => e.id === id);
                if (item) {
                    // Move to resolved problems
                    const resolvedRef = doc(db, 'resolvedProblems', id);
                    await setDoc(resolvedRef, {
                        ...item,
                        status: 'resolved',
                        resolvedBy: currentUser?.email,
                        resolvedAt: serverTimestamp()
                    });
                    
                    // Delete from escalated
                    await deleteDoc(doc(db, 'escalatedProblems', id));
                }
                escalatedItems = escalatedItems.filter(e => e.id !== id);
                updateGovernanceMetrics();
                renderGovernancePanels();
                showToast('Escalation resolved!', 'success');
            } catch (error) {
                console.error('Error resolving escalation:', error);
                showToast('Error: ' + error.message, 'error');
            }
        };
        
        window.govSendBack = async function(id) {
            try {
                const item = escalatedItems.find(e => e.id === id);
                if (item) {
                    // Move back to pending
                    const pendingRef = doc(db, 'pendingProblemApprovals', id);
                    await setDoc(pendingRef, {
                        ...item,
                        status: 'pending',
                        sentBackBy: currentUser?.email,
                        sentBackAt: serverTimestamp()
                    });
                    
                    // Delete from escalated
                    await deleteDoc(doc(db, 'escalatedProblems', id));
                }
                escalatedItems = escalatedItems.filter(e => e.id !== id);
                updateGovernanceMetrics();
                renderGovernancePanels();
                showToast('Item sent back to lower node.', 'success');
            } catch (error) {
                console.error('Error sending back item:', error);
                showToast('Error: ' + error.message, 'error');
            }
        };
        
        window.govForceEscalate = async function(id) {
            try {
                const item = escalatedItems.find(e => e.id === id);
                if (item) {
                    // Update escalation level
                    await setDoc(doc(db, 'escalatedProblems', id), {
                        currentLevel: 'Platform Admin',
                        forceEscalatedBy: currentUser?.email,
                        forceEscalatedAt: serverTimestamp()
                    }, { merge: true });
                }
                showToast('Item escalated to platform admin.', 'success');
            } catch (error) {
                console.error('Error force escalating:', error);
                showToast('Error: ' + error.message, 'error');
            }
        };
        
        window.govRestore = async function(id) {
            const item = archivedItems.find(a => a.id === id);
            if (item) {
                try {
                    // Move back to pending
                    if (item.type === 'problem') {
                        const pendingRef = doc(db, 'pendingProblemApprovals', id);
                        await setDoc(pendingRef, {
                            ...item,
                            status: 'pending',
                            restoredBy: currentUser?.email,
                            restoredAt: serverTimestamp()
                        });
                        pendingProblemApprovals.push({...item, status: 'pending'});
                    } else {
                        const pendingRef = doc(db, 'pendingAnnouncementApprovals', id);
                        await setDoc(pendingRef, {
                            ...item,
                            status: 'pending',
                            restoredBy: currentUser?.email,
                            restoredAt: serverTimestamp()
                        });
                        pendingAnnouncementApprovals.push({...item, status: 'pending'});
                    }
                    
                    // Delete from archived
                    await deleteDoc(doc(db, 'archivedProblems', id));
                    archivedItems = archivedItems.filter(a => a.id !== id);
                    
                    updateGovernanceMetrics();
                    renderGovernancePanels();
                    showToast('Item restored to pending approvals.', 'success');
                } catch (error) {
                    console.error('Error restoring item:', error);
                    showToast('Error: ' + error.message, 'error');
                }
            }
        };
        
        window.viewArchivedItem = function(id) {
            const item = archivedItems.find(a => a.id === id);
            if (item) {
                document.getElementById('modalTitle').textContent = 'Archived Item';
                document.getElementById('modalContent').innerHTML = `
                    <div class="detail-row"><span class="detail-label">Title</span><span class="detail-value">${item.title}</span></div>
                    <div class="detail-row"><span class="detail-label">Type</span><span class="detail-value">${item.type}</span></div>
                    <div class="detail-row"><span class="detail-label">Archive Reason</span><span class="detail-value">${item.archiveReason}</span></div>
                    <div class="detail-row"><span class="detail-label">Archived By</span><span class="detail-value">${item.archivedBy}</span></div>
                    <div class="detail-row"><span class="detail-label">Archived At</span><span class="detail-value">${new Date(item.archivedAt).toLocaleDateString()}</span></div>
                `;
                document.getElementById('detailsModal').classList.add('show');
            }
        };
        
        // Modal openers
        window.openGovRejectModal = function(id, title, type) {
            currentGovAction = { id, type, action: 'reject' };
            document.getElementById('govRejectItemTitle').textContent = title;
            document.getElementById('govRejectReason').value = '';
            document.getElementById('govRejectModal').classList.add('show');
        };
        
        window.openGovEscalateModal = function(id, title, type) {
            currentGovAction = { id, type, action: 'escalate' };
            document.getElementById('govEscalateItemTitle').textContent = title;
            document.getElementById('govEscalateReason').value = '';
            document.getElementById('govEscalateModal').classList.add('show');
        };
        
        window.openGovArchiveModal = function(id, title, type) {
            currentGovAction = { id, type, action: 'archive' };
            document.getElementById('govArchiveItemTitle').textContent = title;
            document.getElementById('govArchiveReason').value = '';
            document.getElementById('govArchiveModal').classList.add('show');
        };
        
        window.openEditAnnouncementModal = function(id) {
            const ann = pendingAnnouncementApprovals.find(a => a.id === id);
            if (ann) {
                currentGovAction = { id, type: 'announcement', action: 'edit' };
                document.getElementById('editAnnouncementTitle').value = ann.title;
                document.getElementById('editAnnouncementContent').value = ann.content;
                document.getElementById('editAnnouncementScope').value = ann.scope || 'node';
                document.getElementById('editAnnouncementVerified').checked = ann.isVerified || false;
                if (ann.deadline) {
                    document.getElementById('editAnnouncementExpiry').value = new Date(ann.deadline).toISOString().split('T')[0];
                }
                document.getElementById('govEditAnnouncementModal').classList.add('show');
            }
        };
        
        // Confirm actions
        document.getElementById('confirmGovRejectBtn')?.addEventListener('click', async function() {
            if (!currentGovAction) return;
            const reason = document.getElementById('govRejectReason').value.trim();
            if (!reason) {
                showToast('Please provide a rejection reason.', 'error');
                return;
            }
            
            try {
                let item;
                if (currentGovAction.type === 'problem') {
                    item = pendingProblemApprovals.find(p => p.id === currentGovAction.id);
                    
                    // Save to rejected collection
                    if (item) {
                        const rejectedRef = doc(db, 'rejectedProblems', currentGovAction.id);
                        await setDoc(rejectedRef, {
                            ...item,
                            status: 'rejected',
                            rejectionReason: reason,
                            rejectedBy: currentUser?.email,
                            rejectedAt: serverTimestamp()
                        });
                    }
                    
                    // Delete from pending
                    await deleteDoc(doc(db, 'pendingProblemApprovals', currentGovAction.id));
                    pendingProblemApprovals = pendingProblemApprovals.filter(p => p.id !== currentGovAction.id);
                } else if (currentGovAction.type === 'announcement') {
                    item = pendingAnnouncementApprovals.find(a => a.id === currentGovAction.id);
                    
                    // Save to rejected collection
                    if (item) {
                        const rejectedRef = doc(db, 'rejectedAnnouncements', currentGovAction.id);
                        await setDoc(rejectedRef, {
                            ...item,
                            status: 'rejected',
                            rejectionReason: reason,
                            rejectedBy: currentUser?.email,
                            rejectedAt: serverTimestamp()
                        });
                    }
                    
                    // Delete from pending
                    await deleteDoc(doc(db, 'pendingAnnouncementApprovals', currentGovAction.id));
                    pendingAnnouncementApprovals = pendingAnnouncementApprovals.filter(a => a.id !== currentGovAction.id);
                }
                
                closeModal('govRejectModal');
                updateGovernanceMetrics();
                renderGovernancePanels();
                showToast('Item rejected.', 'success');
            } catch (error) {
                console.error('Error rejecting item:', error);
                showToast('Error: ' + error.message, 'error');
            }
        });
        
        document.getElementById('confirmGovEscalateBtn')?.addEventListener('click', async function() {
            if (!currentGovAction) return;
            const escalateTo = document.getElementById('govEscalateTo').value;
            const reason = document.getElementById('govEscalateReason').value.trim();
            
            try {
                let item;
                if (currentGovAction.type === 'problem') {
                    item = pendingProblemApprovals.find(p => p.id === currentGovAction.id);
                    
                    // Move to escalated collection
                    if (item) {
                        const escalatedRef = doc(db, 'escalatedProblems', currentGovAction.id);
                        await setDoc(escalatedRef, {
                            ...item,
                            escalationReason: reason || `Escalated to ${escalateTo}`,
                            escalationPath: [...(item.hierarchyPath || []), escalateTo],
                            currentLevel: escalateTo,
                            previousLevel: item.hierarchyPath?.[item.hierarchyPath.length - 1] || 'Unknown',
                            escalatedBy: currentUser?.email,
                            escalatedAt: serverTimestamp()
                        });
                        
                        escalatedItems.push({
                            ...item,
                            escalationReason: reason || `Escalated to ${escalateTo}`,
                            escalationPath: [...(item.hierarchyPath || []), escalateTo],
                            escalatedAt: new Date()
                        });
                    }
                    
                    // Delete from pending
                    await deleteDoc(doc(db, 'pendingProblemApprovals', currentGovAction.id));
                    pendingProblemApprovals = pendingProblemApprovals.filter(p => p.id !== currentGovAction.id);
                } else if (currentGovAction.type === 'announcement') {
                    item = pendingAnnouncementApprovals.find(a => a.id === currentGovAction.id);
                    pendingAnnouncementApprovals = pendingAnnouncementApprovals.filter(a => a.id !== currentGovAction.id);
                }
                
                closeModal('govEscalateModal');
                updateGovernanceMetrics();
                renderGovernancePanels();
                showToast(`Item escalated to ${escalateTo}.`, 'success');
            } catch (error) {
                console.error('Error escalating item:', error);
                showToast('Error: ' + error.message, 'error');
            }
        });
        
        document.getElementById('confirmGovArchiveBtn')?.addEventListener('click', async function() {
            if (!currentGovAction) return;
            const reason = document.getElementById('govArchiveReason').value.trim() || 'Archived by admin';
            
            try {
                let item;
                if (currentGovAction.type === 'problem') {
                    item = pendingProblemApprovals.find(p => p.id === currentGovAction.id);
                    
                    // Move to archived collection
                    if (item) {
                        const archivedRef = doc(db, 'archivedProblems', currentGovAction.id);
                        await setDoc(archivedRef, {
                            ...item,
                            archiveReason: reason,
                            archivedBy: currentUser?.email,
                            archivedAt: serverTimestamp()
                        });
                        
                        archivedItems.push({
                            ...item,
                            archiveReason: reason,
                            archivedBy: currentUser?.email || 'admin',
                            archivedAt: new Date()
                        });
                    }
                    
                    // Delete from pending
                    await deleteDoc(doc(db, 'pendingProblemApprovals', currentGovAction.id));
                    pendingProblemApprovals = pendingProblemApprovals.filter(p => p.id !== currentGovAction.id);
                } else if (currentGovAction.type === 'announcement') {
                    item = pendingAnnouncementApprovals.find(a => a.id === currentGovAction.id);
                    
                    // Move to archived collection
                    if (item) {
                        const archivedRef = doc(db, 'archivedProblems', currentGovAction.id);
                        await setDoc(archivedRef, {
                            ...item,
                            archiveReason: reason,
                            archivedBy: currentUser?.email,
                            archivedAt: serverTimestamp()
                        });
                        
                        archivedItems.push({
                            ...item,
                            archiveReason: reason,
                            archivedBy: currentUser?.email || 'admin',
                            archivedAt: new Date()
                        });
                    }
                    
                    // Delete from pending
                    await deleteDoc(doc(db, 'pendingAnnouncementApprovals', currentGovAction.id));
                    pendingAnnouncementApprovals = pendingAnnouncementApprovals.filter(a => a.id !== currentGovAction.id);
                } else if (currentGovAction.type === 'escalation') {
                    item = escalatedItems.find(e => e.id === currentGovAction.id);
                    
                    // Move to archived collection
                    if (item) {
                        const archivedRef = doc(db, 'archivedProblems', currentGovAction.id);
                        await setDoc(archivedRef, {
                            ...item,
                            archiveReason: reason,
                            archivedBy: currentUser?.email,
                            archivedAt: serverTimestamp()
                        });
                        
                        archivedItems.push({
                            ...item,
                            archiveReason: reason,
                            archivedBy: currentUser?.email || 'admin',
                            archivedAt: new Date()
                        });
                    }
                    
                    // Delete from escalated
                    await deleteDoc(doc(db, 'escalatedProblems', currentGovAction.id));
                    escalatedItems = escalatedItems.filter(e => e.id !== currentGovAction.id);
                }
                
                closeModal('govArchiveModal');
                updateGovernanceMetrics();
                renderGovernancePanels();
                showToast('Item archived.', 'success');
            } catch (error) {
                console.error('Error archiving item:', error);
                showToast('Error: ' + error.message, 'error');
            }
        });
        
        document.getElementById('confirmEditAnnouncementBtn')?.addEventListener('click', function() {
            if (!currentGovAction) return;
            
            const ann = pendingAnnouncementApprovals.find(a => a.id === currentGovAction.id);
            if (ann) {
                ann.title = document.getElementById('editAnnouncementTitle').value;
                ann.content = document.getElementById('editAnnouncementContent').value;
                ann.scope = document.getElementById('editAnnouncementScope').value;
                ann.isVerified = document.getElementById('editAnnouncementVerified').checked;
                const expiry = document.getElementById('editAnnouncementExpiry').value;
                if (expiry) ann.deadline = new Date(expiry);
            }
            
            closeModal('govEditAnnouncementModal');
            renderGovernancePanels();
            showToast('Announcement updated.', 'success');
        });

        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const icon = toast.querySelector('i');
            document.getElementById('toastMessage').textContent = message;
            toast.className = `toast show ${type}`;
            icon.className = type === 'success' ? 'fas fa-check-circle' : 'fas fa-exclamation-circle';
            icon.style.color = type === 'success' ? '#10B981' : '#EF4444';
            setTimeout(() => toast.classList.remove('show'), 3000);
        }
    </script>
</body>
</html>