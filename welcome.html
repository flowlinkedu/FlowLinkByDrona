<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Network - FlowLink</title>

    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=PT+Sans:wght@400;700&display=swap"
        rel="stylesheet">

    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Lucide Icons CDN -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>

    <style>
        :root {
            --background: #ffffff;
            --foreground: #0a0a0a;
            --card: #ffffff;
            --card-foreground: #0a0a0a;
            --primary: #29ABE2;
            --primary-foreground: #ffffff;
            --secondary: #f5f5f5;
            --secondary-foreground: #171717;
            --muted: #f5f5f5;
            --muted-foreground: #737373;
            --accent: #29E2D0;
            --accent-foreground: #171717;
            --destructive: #ef4444;
            --border: #e5e5e5;
            --ring: #29ABE2;
            --radius: 0.5rem;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'PT Sans', sans-serif;
            background: linear-gradient(135deg, #E5F6FD 0%, rgba(41, 171, 226, 0.1) 100%);
            min-height: 100vh;
            color: var(--foreground);
        }

        .font-headline {
            font-family: 'Poppins', sans-serif;
        }

        /* Page Layout */
        .page-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        /* Header Section */
        .page-header {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        @media (min-width: 768px) {
            .page-header {
                flex-direction: row;
                align-items: center;
            }
        }

        .page-header h1 {
            font-size: 1.875rem;
            font-weight: 700;
            letter-spacing: -0.025em;
        }

        .page-header p {
            color: var(--muted-foreground);
        }

        .header-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            font-weight: 500;
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
            text-decoration: none;
        }

        .btn-primary {
            background: var(--primary);
            color: var(--primary-foreground);
            border-color: var(--primary);
        }

        .btn-primary:hover {
            background: #1e9ad1;
        }

        .btn-outline {
            background: transparent;
            color: var(--foreground);
            border-color: var(--border);
        }

        .btn-outline:hover {
            background: var(--secondary);
        }

        .btn-success {
            background: #10b981;
            color: white;
            border-color: #10b981;
        }

        .btn-success:hover {
            background: #059669;
        }

        .btn-ghost {
            background: transparent;
            color: var(--foreground);
            border: none;
            padding: 0.25rem 0.5rem;
        }

        .btn-ghost:hover {
            background: var(--secondary);
        }

        .btn-sm {
            padding: 0.25rem 0.75rem;
            font-size: 0.75rem;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Card */
        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1rem;
            overflow-x: auto;
        }

        @media (min-width: 768px) {
            .card {
                padding: 2rem;
            }
        }

        .card-content {
            display: inline-block;
            min-width: 100%;
            padding: 1rem 0;
            text-align: center;
        }

        /* Skeleton Loading */
        .skeleton {
            background: linear-gradient(90deg, var(--muted) 25%, #e8e8e8 50%, var(--muted) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: var(--radius);
        }

        @keyframes shimmer {
            0% {
                background-position: 200% 0;
            }

            100% {
                background-position: -200% 0;
            }
        }

        .skeleton-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .skeleton-node {
            width: 16rem;
            height: 8rem;
        }

        .skeleton-line {
            width: 1px;
            height: 2rem;
            background: var(--border);
        }

        .skeleton-children {
            display: flex;
            justify-content: center;
            gap: 2rem;
        }

        /* Flowchart Container */
        .flowchart-container {
            display: flex;
            justify-content: center;
            gap: 2rem;
            flex-wrap: wrap;
        }

        /* Flowchart Node */
        .flowchart-node {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .node-card {
            width: 16rem;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1rem;
            text-align: left;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .node-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-color: var(--primary);
        }

        .node-card.root {
            background: linear-gradient(135deg, var(--primary), var(--accent));
            color: white;
            border: none;
        }

        .node-card.root .node-meta,
        .node-card.root .node-path {
            color: rgba(255, 255, 255, 0.8);
        }

        .node-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .node-title {
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            font-size: 1rem;
            line-height: 1.25;
        }

        .node-meta {
            font-size: 0.75rem;
            color: var(--muted-foreground);
            margin-bottom: 0.5rem;
        }

        .node-path {
            font-size: 0.65rem;
            color: var(--muted-foreground);
            font-family: monospace;
            word-break: break-all;
            background: rgba(0, 0, 0, 0.05);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            margin-bottom: 0.75rem;
        }

        .node-card.root .node-path {
            background: rgba(255, 255, 255, 0.2);
        }

        .node-actions {
            display: flex;
            gap: 0.25rem;
            flex-wrap: wrap;
        }

        .node-actions .btn {
            flex: 1;
            min-width: fit-content;
        }

        /* Tree Connector */
        .tree-connector {
            width: 2px;
            height: 1.5rem;
            background: var(--border);
            margin: 0.5rem 0;
        }

        /* Children Container */
        .children-wrapper {
            position: relative;
            margin-top: 0.5rem;
        }

        .children-horizontal-line {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            height: 2px;
            background: var(--border);
        }

        .children-container {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            padding-top: 1.5rem;
            position: relative;
        }

        .child-branch {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .child-branch::before {
            content: '';
            position: absolute;
            top: -1.5rem;
            left: 50%;
            width: 2px;
            height: 1.5rem;
            background: var(--border);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 3rem;
            color: var(--muted-foreground);
        }

        .empty-state i {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .empty-state h3 {
            font-family: 'Poppins', sans-serif;
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
            color: var(--foreground);
        }

        .empty-state p {
            margin-bottom: 1.5rem;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1rem;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: var(--card);
            border-radius: var(--radius);
            width: 100%;
            max-width: 28rem;
            max-height: 90vh;
            overflow-y: auto;
            animation: modalIn 0.2s ease;
        }

        @keyframes modalIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
        }

        .modal-title {
            font-family: 'Poppins', sans-serif;
            font-size: 1.125rem;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--muted-foreground);
            padding: 0.25rem;
        }

        .modal-close:hover {
            color: var(--foreground);
        }

        .modal-body {
            padding: 1.5rem;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border);
        }

        /* Form */
        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.375rem;
        }

        .form-label .required {
            color: var(--destructive);
        }

        .form-input {
            width: 100%;
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--background);
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--ring);
            box-shadow: 0 0 0 3px rgba(41, 171, 226, 0.1);
        }

        .form-hint {
            font-size: 0.75rem;
            color: var(--muted-foreground);
            margin-top: 0.25rem;
        }

        .form-error {
            font-size: 0.75rem;
            color: var(--destructive);
            margin-top: 0.25rem;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: none;
            align-items: center;
            gap: 0.75rem;
            z-index: 1001;
            animation: toastIn 0.3s ease;
        }

        .toast.show {
            display: flex;
        }

        .toast.success {
            border-left: 4px solid #10b981;
        }

        .toast.error {
            border-left: 4px solid var(--destructive);
        }

        @keyframes toastIn {
            from {
                opacity: 0;
                transform: translateY(1rem);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Responsive */
        @media (max-width: 640px) {
            .page-container {
                padding: 1rem;
            }

            .node-card {
                width: 14rem;
            }

            .children-container {
                flex-direction: column;
                align-items: center;
                gap: 1rem;
            }

            .child-branch::before {
                display: none;
            }

            .children-horizontal-line {
                display: none;
            }
        }
    </style>
</head>

<body>
    <div class="page-container">
        <!-- Header -->
        <div class="page-header">
            <div>
                <h1 class="font-headline">My Network</h1>
                <p>Visualize your affiliations and manage your network nodes.</p>
            </div>
            <div class="header-actions">
                <button class="btn btn-outline" id="addNodeBtn">
                    <i data-lucide="plus-circle" style="width: 16px; height: 16px;"></i>
                    Add Node
                </button>
                <button class="btn btn-success" id="doneBtn">
                    <i data-lucide="check" style="width: 16px; height: 16px;"></i>
                    Done
                </button>
            </div>
        </div>

        <!-- Main Card -->
        <div class="card">
            <div class="card-content">
                <!-- Loading Skeleton -->
                <div class="skeleton-container" id="loadingSkeleton">
                    <div class="skeleton skeleton-node"></div>
                    <div class="skeleton-line"></div>
                    <div class="skeleton-children">
                        <div class="skeleton skeleton-node"></div>
                        <div class="skeleton skeleton-node"></div>
                    </div>
                </div>

                <!-- Empty State -->
                <div class="empty-state" id="emptyState" style="display: none;">
                    <i class="fas fa-sitemap"></i>
                    <h3>No Network Setup Yet</h3>
                    <p>You haven't set up your network yet. Create your first node to build your affiliation tree.</p>
                    <button class="btn btn-primary" id="createFirstBtn">
                        <i data-lucide="plus-circle" style="width: 16px; height: 16px;"></i>
                        Create First Node
                    </button>
                </div>

                <!-- Flowchart -->
                <div class="flowchart-container" id="flowchartContainer" style="display: none;"></div>
            </div>
        </div>
    </div>

    <!-- Add/Edit Node Modal -->
    <div class="modal-overlay" id="nodeModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title" id="modalTitle">Add New Node</h2>
                <button class="modal-close" id="closeModal">
                    <i data-lucide="x" style="width: 20px; height: 20px;"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Name <span class="required">*</span></label>
                    <input type="text" class="form-input" id="nodeName" placeholder="Enter node name">
                    <p class="form-error" id="nodeNameError" style="display: none;"></p>
                </div>
                <div class="form-group">
                    <label class="form-label">Type</label>
                    <select class="form-input" id="nodeType">
                        <option value="organization">Organization</option>
                        <option value="department">Department</option>
                        <option value="team">Team</option>
                        <option value="project">Project</option>
                        <option value="academic">Academic</option>
                        <option value="hostel">Hostel</option>
                        <option value="sports">Sports</option>
                        <option value="club">Club</option>
                    </select>
                </div>

            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" id="cancelBtn">Cancel</button>
                <button class="btn btn-primary" id="saveBtn">Save</button>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div class="modal-overlay" id="deleteModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">Delete Node</h2>
                <button class="modal-close" id="closeDeleteModal">
                    <i data-lucide="x" style="width: 20px; height: 20px;"></i>
                </button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to delete <strong id="deleteNodeName"></strong>?</p>
                <p style="color: var(--destructive); margin-top: 0.5rem; font-size: 0.875rem;">This will also delete all
                    child nodes.</p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" id="cancelDeleteBtn">Cancel</button>
                <button class="btn" style="background: var(--destructive); color: white;"
                    id="confirmDeleteBtn">Delete</button>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast">
        <i data-lucide="check-circle" style="width: 20px; height: 20px; color: #10b981;" id="toastIcon"></i>
        <span id="toastMessage">Success!</span>
    </div>

</body>

</html>

<!-- Firebase Integration -->
<script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
    import {
        getFirestore, doc, setDoc, deleteDoc, collection, getDocs, serverTimestamp, getDoc, arrayUnion, arrayRemove
    } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

    // Firebase config
    const firebaseConfig = {
        apiKey: "AIzaSyBsuZL4U2H66C9tUKN91KXMm-l5umOa1vY",
        authDomain: "flowlinkkiro.firebaseapp.com",
        projectId: "flowlinkkiro",
        storageBucket: "flowlinkkiro.firebasestorage.app",
        messagingSenderId: "918596906932",
        appId: "1:918596906932:web:55e2a235cefedd61098ce1",
        measurementId: "G-B32FNF648G"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // State
    let currentUser = null;
    let hierarchyData = [];
    let editingNode = null;
    let parentDocRef = null; // Reference to parent document for adding child nodes
    let nodeToDelete = null;

    // DOM Elements
    const loadingSkeleton = document.getElementById('loadingSkeleton');
    const emptyState = document.getElementById('emptyState');
    const flowchartContainer = document.getElementById('flowchartContainer');
    const nodeModal = document.getElementById('nodeModal');
    const deleteModal = document.getElementById('deleteModal');
    const toast = document.getElementById('toast');

    // Initialize Lucide icons
    lucide.createIcons();

    // Auth listener
    onAuthStateChanged(auth, async (user) => {
        if (user) {
            currentUser = user;
            await loadHierarchy();
        } else {
            window.location.href = 'login.html';
        }
    });

    // Recursive fetch using 'sub-nodes' collection for children
    // Path: /users/{email}/hierarchies/{orgId}/sub-nodes/{nodeId}/sub-nodes/{subNodeId}...
    async function fetchNodesRecursive(colRef, basePath) {
        const nodes = [];
        try {
            const snapshot = await getDocs(colRef);

            for (const docSnap of snapshot.docs) {
                const data = docSnap.data();
                const nodePath = `${basePath}/${docSnap.id}`;

                // Get status from global hierarchy (in case super admin updated it)
                const globalPath = getGlobalHierarchyPath(nodePath);
                let status = data.status || 'pending';
                try {
                    const globalDocRef = doc(db, globalPath);
                    const globalDoc = await getDoc(globalDocRef);
                    if (globalDoc.exists()) {
                        status = globalDoc.data().status || status;
                    }
                } catch (e) {
                    // Use local status if global fetch fails
                }

                // Fetch children from 'sub-nodes' collection
                const childrenRef = collection(docSnap.ref, 'sub-nodes');
                const children = await fetchNodesRecursive(childrenRef, `${nodePath}/sub-nodes`);

                nodes.push({
                    id: docSnap.id,
                    name: data.name || docSnap.id,
                    type: data.type || 'organization',
                    admins: data.adminEmails || [],
                    status: status,
                    path: nodePath,
                    docRef: docSnap.ref,
                    children: children
                });
            }
        } catch (e) {
            // No children or error - this is normal for leaf nodes
        }
        return nodes;
    }

    async function loadHierarchy() {
        showLoading();
        try {
            const hierarchiesRef = collection(db, 'users', currentUser.email, 'hierarchies');
            const basePath = `users/${currentUser.email}/hierarchies`;
            hierarchyData = await fetchNodesRecursive(hierarchiesRef, basePath);
            renderFlowchart();
        } catch (error) {
            console.error('Error loading hierarchy:', error);
            showToast('Failed to load hierarchy', 'error');
        }
    }

    function showLoading() {
        loadingSkeleton.style.display = 'flex';
        emptyState.style.display = 'none';
        flowchartContainer.style.display = 'none';
    }

    function renderFlowchart() {
        loadingSkeleton.style.display = 'none';

        if (hierarchyData.length === 0) {
            emptyState.style.display = 'block';
            flowchartContainer.style.display = 'none';
            return;
        }

        emptyState.style.display = 'none';
        flowchartContainer.style.display = 'flex';
        flowchartContainer.innerHTML = '';

        hierarchyData.forEach(node => {
            const nodeEl = createNodeElement(node, true);
            flowchartContainer.appendChild(nodeEl);
        });

        lucide.createIcons();
    }

    function createNodeElement(node, isRoot = false) {
        const wrapper = document.createElement('div');
        wrapper.className = 'flowchart-node';

        // Determine status display
        const statusClass = node.status === 'active' ? 'active' : (node.status === 'suspended' ? 'suspended' : 'pending');
        const statusText = node.status === 'active' ? 'Approved' : (node.status === 'suspended' ? 'Rejected' : 'Pending Approval');
        const statusColor = node.status === 'active' ? '#10B981' : (node.status === 'suspended' ? '#EF4444' : '#F59E0B');

        const card = document.createElement('div');
        card.className = `node-card ${isRoot ? 'root' : ''}`;
        card.innerHTML = `
                <div class="node-header">
                    <span class="node-title">${node.name}</span>
                </div>
                <div class="node-meta">${node.type} â€¢ <span style="color: ${statusColor}; font-weight: 600;">${statusText}</span></div>
                <div class="node-actions">
                    <button class="btn btn-ghost btn-sm add-child-btn" title="Add Child">
                        <i data-lucide="plus" style="width: 14px; height: 14px;"></i>
                    </button>
                    <button class="btn btn-ghost btn-sm edit-btn" title="Edit">
                        <i data-lucide="pencil" style="width: 14px; height: 14px;"></i>
                    </button>
                    <button class="btn btn-ghost btn-sm delete-btn" title="Delete">
                        <i data-lucide="trash-2" style="width: 14px; height: 14px;"></i>
                    </button>
                </div>
            `;

        // Event listeners
        card.querySelector('.add-child-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            openAddChildModal(node);
        });

        card.querySelector('.edit-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            openEditModal(node);
        });

        card.querySelector('.delete-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            openDeleteModal(node);
        });

        wrapper.appendChild(card);

        // Render children
        if (node.children && node.children.length > 0) {
            const connector = document.createElement('div');
            connector.className = 'tree-connector';
            wrapper.appendChild(connector);

            const childrenWrapper = document.createElement('div');
            childrenWrapper.className = 'children-wrapper';

            const horizontalLine = document.createElement('div');
            horizontalLine.className = 'children-horizontal-line';
            const totalWidth = (node.children.length - 1) * 200;
            horizontalLine.style.width = `${totalWidth}px`;
            childrenWrapper.appendChild(horizontalLine);

            const childrenContainer = document.createElement('div');
            childrenContainer.className = 'children-container';

            node.children.forEach(child => {
                const childBranch = document.createElement('div');
                childBranch.className = 'child-branch';
                const childEl = createNodeElement(child, false);
                childBranch.appendChild(childEl);
                childrenContainer.appendChild(childBranch);
            });

            childrenWrapper.appendChild(childrenContainer);
            wrapper.appendChild(childrenWrapper);
        }

        return wrapper;
    }

    // Sanitize name for document ID
    function sanitizeName(name) {
        return name.toLowerCase().trim()
            .replace(/\s+/g, '-')
            .replace(/[^a-z0-9-_]/g, '')
            .replace(/-+/g, '-')
            .replace(/^-|-$/g, '');
    }

    // Modal functions
    function openAddModal() {
        editingNode = null;
        parentDocRef = null; // Root level - will create in hierarchies collection
        document.getElementById('modalTitle').textContent = 'Add Organization';
        document.getElementById('nodeName').value = '';
        document.getElementById('nodeType').value = 'organization';
        document.getElementById('nodeNameError').style.display = 'none';
        nodeModal.classList.add('show');
        lucide.createIcons();
    }

    function openAddChildModal(parentNode) {
        editingNode = null;
        parentDocRef = parentNode.docRef; // Will create in parent's children collection
        document.getElementById('modalTitle').textContent = 'Add Sub-node';
        document.getElementById('nodeName').value = '';
        document.getElementById('nodeType').value = 'department';
        document.getElementById('nodeNameError').style.display = 'none';
        nodeModal.classList.add('show');
        lucide.createIcons();
    }

    function openEditModal(node) {
        editingNode = node;
        parentDocRef = null;
        document.getElementById('modalTitle').textContent = 'Edit Node';
        document.getElementById('nodeName').value = node.name;
        document.getElementById('nodeType').value = node.type;
        document.getElementById('nodeNameError').style.display = 'none';
        nodeModal.classList.add('show');
        lucide.createIcons();
    }

    function openDeleteModal(node) {
        nodeToDelete = node;
        document.getElementById('deleteNodeName').textContent = node.name;
        deleteModal.classList.add('show');
        lucide.createIcons();
    }

    function closeNodeModal() {
        nodeModal.classList.remove('show');
        editingNode = null;
        parentDocRef = null;
    }

    function closeDeleteModal() {
        deleteModal.classList.remove('show');
        nodeToDelete = null;
    }

    // Helper function to build global hierarchy path from user hierarchy path
    // Both use same structure now: hierarchies/{orgId}/sub-nodes/{nodeId}/sub-nodes/{subNodeId}
    // Just removes the users/{email}/ prefix
    function getGlobalHierarchyPath(userPath) {
        const parts = userPath.split('/');
        // parts[0] = 'users', parts[1] = email, parts[2] = 'hierarchies', rest is the path
        return parts.slice(2).join('/');
    }

    // Find existing global hierarchy by name alias
    async function findGlobalHierarchyByAlias(sanitizedName, name, parentPath = null) {
        try {
            // Determine the collection to search
            let searchPath;
            if (parentPath) {
                // Search in parent's sub-nodes collection
                searchPath = `${parentPath}/sub-nodes`;
            } else {
                // Search in root hierarchies collection
                searchPath = 'hierarchies';
            }

            const colRef = collection(db, searchPath);
            const snapshot = await getDocs(colRef);

            for (const docSnap of snapshot.docs) {
                const data = docSnap.data();
                const nameAliases = data.nameAliases || [data.name];

                // Check if any alias matches the sanitized name or original name
                const normalizedAliases = nameAliases.map(a => sanitizeName(a));
                if (normalizedAliases.includes(sanitizedName) ||
                    nameAliases.some(a => a.toLowerCase() === name.toLowerCase())) {
                    return {
                        docId: docSnap.id,
                        docRef: docSnap.ref,
                        data: data,
                        path: `${searchPath}/${docSnap.id}`
                    };
                }
            }
            return null;
        } catch (error) {
            console.error('Error finding global hierarchy by alias:', error);
            return null;
        }
    }

    // Create or update node in global hierarchies collection
    async function syncToGlobalHierarchy(userPath, nodeData, isDelete = false) {
        try {
            const globalPath = getGlobalHierarchyPath(userPath);
            const pathParts = globalPath.split('/');
            const sanitizedName = pathParts[pathParts.length - 1];

            // Determine parent path for alias search
            let parentGlobalPath = null;
            if (pathParts.length > 2) {
                // Has parent - get parent path (everything except last two parts: sub-nodes/name)
                parentGlobalPath = pathParts.slice(0, -2).join('/');
            }

            // Try to find existing hierarchy by alias
            const existingHierarchy = await findGlobalHierarchyByAlias(
                sanitizedName,
                nodeData.name,
                parentGlobalPath
            );

            if (isDelete) {
                // Remove user from members array
                const targetRef = existingHierarchy ? existingHierarchy.docRef : doc(db, globalPath);
                const globalDoc = await getDoc(targetRef);

                if (globalDoc.exists()) {
                    const data = globalDoc.data();
                    const updatedMembers = (data.members || []).filter(m => m !== currentUser.email);

                    if (updatedMembers.length === 0) {
                        // No more members, delete the global node
                        await deleteDoc(targetRef);
                        console.log(`Global hierarchy deleted: ${targetRef.path}`);
                    } else {
                        // Update members list
                        await setDoc(targetRef, {
                            members: updatedMembers,
                            updatedAt: serverTimestamp()
                        }, { merge: true });
                        console.log(`User removed from global hierarchy: ${targetRef.path}`);
                    }
                }
            } else {
                if (existingHierarchy) {
                    // Found existing hierarchy - add user to it and add name to aliases if new
                    const existingAliases = existingHierarchy.data.nameAliases || [existingHierarchy.data.name];
                    const nameAlreadyExists = existingAliases.some(
                        a => a.toLowerCase() === nodeData.name.toLowerCase()
                    );

                    const updateData = {
                        members: arrayUnion(currentUser.email),
                        updatedAt: serverTimestamp()
                    };

                    // Add new name alias if it doesn't exist
                    if (!nameAlreadyExists) {
                        updateData.nameAliases = arrayUnion(nodeData.name);
                    }

                    await setDoc(existingHierarchy.docRef, updateData, { merge: true });
                    console.log(`User added to existing global hierarchy: ${existingHierarchy.path}`);

                    // Return the actual path used (for updating user's reference if needed)
                    return existingHierarchy.path;
                } else {
                    // Create new global node with pending status
                    const globalDocRef = doc(db, globalPath);
                    await setDoc(globalDocRef, {
                        name: nodeData.name,
                        nameAliases: [nodeData.name], // Initialize aliases array with original name
                        type: nodeData.type,
                        adminEmails: [], // No admins until super admin assigns
                        members: [currentUser.email],
                        status: 'pending', // Pending until super admin approves
                        createdAt: serverTimestamp(),
                        createdBy: currentUser.email,
                        updatedAt: serverTimestamp()
                    });
                    console.log(`Global hierarchy created (pending approval): ${globalPath}`);

                    // Create pending approval document for super admin review
                    const approvalId = `${sanitizedName}-${Date.now()}`;
                    const pendingApprovalRef = doc(db, 'pendingApprovals', approvalId);
                    await setDoc(pendingApprovalRef, {
                        approvalId: approvalId,
                        name: nodeData.name,
                        type: nodeData.type,
                        hierarchyPath: globalPath,
                        createdBy: currentUser.email,
                        createdAt: serverTimestamp(),
                        status: 'pending'
                    });
                    console.log(`Pending approval created: ${approvalId}`);

                    return globalPath;
                }
            }
        } catch (error) {
            console.error('Error syncing to global hierarchy:', error);
            // Don't throw - global sync failure shouldn't block user operation
        }
        return null;
    }

    // Recursively delete from global hierarchy
    async function deleteFromGlobalHierarchyRecursive(userPath) {
        try {
            const globalPath = getGlobalHierarchyPath(userPath);
            const globalDocRef = doc(db, globalPath);            // First handle children in 'sub-nodes' collection
            const childrenRef = collection(globalDocRef, 'sub-nodes');
            try {
                const snapshot = await getDocs(childrenRef);
                for (const docSnap of snapshot.docs) {
                    await deleteFromGlobalHierarchyRecursive(`${userPath}/sub-nodes/${docSnap.id}`);
                }
            } catch (e) {
                // No children
            }

            // Then handle this node
            const globalDoc = await getDoc(globalDocRef);
            if (globalDoc.exists()) {
                const data = globalDoc.data();
                const updatedMembers = (data.members || []).filter(m => m !== currentUser.email);

                if (updatedMembers.length === 0) {
                    await deleteDoc(globalDocRef);
                    console.log(`Global hierarchy deleted: ${globalPath}`);
                } else {
                    await setDoc(globalDocRef, {
                        members: updatedMembers,
                        updatedAt: serverTimestamp()
                    }, { merge: true });
                    console.log(`User removed from global hierarchy: ${globalPath}`);
                }
            }
        } catch (error) {
            console.error('Error deleting from global hierarchy:', error);
        }
    }

    // Save node
    async function saveNode() {
        const name = document.getElementById('nodeName').value.trim();

        if (!name) {
            document.getElementById('nodeNameError').textContent = 'Name is required';
            document.getElementById('nodeNameError').style.display = 'block';
            return;
        }

        const sanitizedName = sanitizeName(name);
        const nodeType = document.getElementById('nodeType').value;

        const saveBtn = document.getElementById('saveBtn');
        saveBtn.disabled = true;
        saveBtn.textContent = 'Saving...';

        try {
            let newNodePath = '';
            const nodeData = {
                name: name,
                type: nodeType
            };

            if (editingNode) {
                // Update existing node
                await setDoc(editingNode.docRef, {
                    name: name,
                    type: nodeType,
                    updatedAt: serverTimestamp()
                }, { merge: true });
                newNodePath = editingNode.path;

                // Sync update to global hierarchy
                await syncToGlobalHierarchy(newNodePath, nodeData);
            } else if (parentDocRef) {
                // Create child node in 'sub-nodes' collection
                const childrenRef = collection(parentDocRef, 'sub-nodes');
                const newDocRef = doc(childrenRef, sanitizedName);
                await setDoc(newDocRef, {
                    name: name,
                    type: nodeType,
                    status: 'pending', // Pending until super admin approves
                    createdAt: serverTimestamp(),
                    createdBy: currentUser.email
                });
                newNodePath = `${parentDocRef.path}/sub-nodes/${sanitizedName}`;

                // Sync to global hierarchy
                await syncToGlobalHierarchy(newNodePath, nodeData);
            } else {
                // Create root node in hierarchies collection
                const hierarchiesRef = collection(db, 'users', currentUser.email, 'hierarchies');
                const newDocRef = doc(hierarchiesRef, sanitizedName);
                await setDoc(newDocRef, {
                    name: name,
                    type: nodeType,
                    status: 'pending', // Pending until super admin approves
                    createdAt: serverTimestamp(),
                    createdBy: currentUser.email
                });
                newNodePath = `users/${currentUser.email}/hierarchies/${sanitizedName}`;

                // Sync to global hierarchy
                await syncToGlobalHierarchy(newNodePath, nodeData);
            }

            closeNodeModal();
            showToast('Node saved successfully!', 'success');
            await loadHierarchy();
        } catch (error) {
            console.error('Error saving node:', error);
            showToast('Failed to save node: ' + error.message, 'error');
        } finally {
            saveBtn.disabled = false;
            saveBtn.textContent = 'Save';
        }
    }

    // Delete node recursively (delete all children first) - from user's collection
    async function deleteNodeRecursive(docRef) {
        try {
            // First delete all children from 'sub-nodes' collection
            const childrenRef = collection(docRef, 'sub-nodes');
            const snapshot = await getDocs(childrenRef);
            for (const docSnap of snapshot.docs) {
                await deleteNodeRecursive(docSnap.ref);
            }
        } catch (e) {
            // No children
        }

        // Then delete the node itself
        await deleteDoc(docRef);
    }

    async function deleteNode() {
        if (!nodeToDelete) return;

        const confirmBtn = document.getElementById('confirmDeleteBtn');
        confirmBtn.disabled = true;
        confirmBtn.textContent = 'Deleting...';

        try {
            // First, sync deletion to global hierarchy (remove user from members)
            await deleteFromGlobalHierarchyRecursive(nodeToDelete.path);

            // Then delete from user's collection
            await deleteNodeRecursive(nodeToDelete.docRef);
            closeDeleteModal();
            showToast('Node deleted successfully!', 'success');
            await loadHierarchy();
        } catch (error) {
            console.error('Error deleting node:', error);
            showToast('Failed to delete node', 'error');
        } finally {
            confirmBtn.disabled = false;
            confirmBtn.textContent = 'Delete';
        }
    }

    // Toast
    function showToast(message, type = 'success') {
        const toastIcon = document.getElementById('toastIcon');
        document.getElementById('toastMessage').textContent = message;
        toast.className = `toast show ${type}`;

        if (type === 'error') {
            toastIcon.setAttribute('data-lucide', 'alert-circle');
            toastIcon.style.color = 'var(--destructive)';
        } else {
            toastIcon.setAttribute('data-lucide', 'check-circle');
            toastIcon.style.color = '#10b981';
        }
        lucide.createIcons();

        setTimeout(() => {
            toast.classList.remove('show');
        }, 3000);
    }

    // Done button
    function handleDone() {
        if (hierarchyData.length === 0) {
            showToast('Please create at least one node before continuing.', 'error');
            return;
        }
        showToast('Network setup complete! Redirecting...', 'success');
        setTimeout(() => {
            window.location.href = 'dashboard.html';
        }, 1500);
    }

    // Event listeners
    document.getElementById('addNodeBtn').addEventListener('click', openAddModal);
    document.getElementById('createFirstBtn').addEventListener('click', openAddModal);
    document.getElementById('doneBtn').addEventListener('click', handleDone);
    document.getElementById('closeModal').addEventListener('click', closeNodeModal);
    document.getElementById('cancelBtn').addEventListener('click', closeNodeModal);
    document.getElementById('saveBtn').addEventListener('click', saveNode);
    document.getElementById('closeDeleteModal').addEventListener('click', closeDeleteModal);
    document.getElementById('cancelDeleteBtn').addEventListener('click', closeDeleteModal);
    document.getElementById('confirmDeleteBtn').addEventListener('click', deleteNode);
    document.getElementById('nodeName').addEventListener('input', () => {
        document.getElementById('nodeNameError').style.display = 'none';
    });

    nodeModal.addEventListener('click', (e) => { if (e.target === nodeModal) closeNodeModal(); });
    deleteModal.addEventListener('click', (e) => { if (e.target === deleteModal) closeDeleteModal(); });
</script>
</body>

</html>